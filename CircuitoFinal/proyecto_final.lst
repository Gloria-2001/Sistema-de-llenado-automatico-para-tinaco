CCS PCM C Compiler, Version 5.025, 19800               13-dic.-21 20:29

               Filename:   C:\Users\vivis\Documents\ESCOM\QUINTO SEMESTRE ESCOM\Instrumentación\Sistema-de-llenado-automatico-para-tinaco\Proyecto Final\proyecto_final.lst

               ROM used:   4471 words (55%)
                           Largest free fragment is 2048
               RAM used:   66 (18%) at main() level
                           132 (36%) worst case
               Stack used: 3 locations
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16f877a.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
*
0019:  MOVLW  8E
001A:  MOVWF  77
001B:  BSF    03.5
001C:  MOVF   35,W
001D:  MOVWF  78
001E:  MOVF   34,W
001F:  MOVWF  79
0020:  CLRF   7A
0021:  MOVF   78,F
0022:  BTFSS  03.2
0023:  GOTO   02E
0024:  MOVF   79,W
0025:  MOVWF  78
0026:  CLRF   79
0027:  MOVLW  08
0028:  SUBWF  77,F
0029:  MOVF   78,F
002A:  BTFSS  03.2
002B:  GOTO   02E
002C:  CLRF   77
002D:  GOTO   036
002E:  BCF    03.0
002F:  BTFSC  78.7
0030:  GOTO   035
0031:  RLF    79,F
0032:  RLF    78,F
0033:  DECF   77,F
0034:  GOTO   02E
0035:  BCF    78.7
0036:  BCF    03.5
0037:  RETURN
0038:  BSF    03.5
0039:  MOVF   31,W
003A:  MOVWF  38
003B:  MOVF   35,W
003C:  XORWF  38,F
003D:  BTFSS  38.7
003E:  GOTO   044
003F:  BCF    03.2
0040:  BCF    03.0
0041:  BTFSC  31.7
0042:  BSF    03.0
0043:  GOTO   077
0044:  MOVF   31,W
0045:  MOVWF  38
0046:  MOVF   34,W
0047:  MOVWF  39
0048:  MOVF   30,W
0049:  SUBWF  39,F
004A:  BTFSC  03.2
004B:  GOTO   052
004C:  BTFSS  38.7
004D:  GOTO   077
004E:  MOVF   03,W
004F:  XORLW  01
0050:  MOVWF  03
0051:  GOTO   077
0052:  MOVF   35,W
0053:  MOVWF  39
0054:  MOVF   31,W
0055:  SUBWF  39,F
0056:  BTFSC  03.2
0057:  GOTO   05E
0058:  BTFSS  38.7
0059:  GOTO   077
005A:  MOVF   03,W
005B:  XORLW  01
005C:  MOVWF  03
005D:  GOTO   077
005E:  MOVF   36,W
005F:  MOVWF  39
0060:  MOVF   32,W
0061:  SUBWF  39,F
0062:  BTFSC  03.2
0063:  GOTO   06A
0064:  BTFSS  38.7
0065:  GOTO   077
0066:  MOVF   03,W
0067:  XORLW  01
0068:  MOVWF  03
0069:  GOTO   077
006A:  MOVF   37,W
006B:  MOVWF  39
006C:  MOVF   33,W
006D:  SUBWF  39,F
006E:  BTFSC  03.2
006F:  GOTO   076
0070:  BTFSS  38.7
0071:  GOTO   077
0072:  MOVF   03,W
0073:  XORLW  01
0074:  MOVWF  03
0075:  GOTO   077
0076:  BCF    03.0
0077:  BCF    03.5
0078:  RETURN
0079:  BSF    03.5
007A:  MOVF   29,W
007B:  BTFSC  03.2
007C:  GOTO   13F
007D:  MOVWF  35
007E:  MOVF   2D,W
007F:  BTFSC  03.2
0080:  GOTO   13F
0081:  SUBWF  35,F
0082:  BTFSS  03.0
0083:  GOTO   089
0084:  MOVLW  7F
0085:  ADDWF  35,F
0086:  BTFSC  03.0
0087:  GOTO   13F
0088:  GOTO   08F
0089:  MOVLW  81
008A:  SUBWF  35,F
008B:  BTFSS  03.0
008C:  GOTO   13F
008D:  BTFSC  03.2
008E:  GOTO   13F
008F:  MOVF   35,W
0090:  MOVWF  77
0091:  CLRF   78
0092:  CLRF   79
0093:  CLRF   7A
0094:  CLRF   34
0095:  MOVF   2A,W
0096:  MOVWF  33
0097:  BSF    33.7
0098:  MOVF   2B,W
0099:  MOVWF  32
009A:  MOVF   2C,W
009B:  MOVWF  31
009C:  MOVLW  19
009D:  MOVWF  35
009E:  MOVF   30,W
009F:  SUBWF  31,F
00A0:  BTFSC  03.0
00A1:  GOTO   0B2
00A2:  MOVLW  01
00A3:  SUBWF  32,F
00A4:  BTFSC  03.0
00A5:  GOTO   0B2
00A6:  SUBWF  33,F
00A7:  BTFSC  03.0
00A8:  GOTO   0B2
00A9:  SUBWF  34,F
00AA:  BTFSC  03.0
00AB:  GOTO   0B2
00AC:  INCF   34,F
00AD:  INCF   33,F
00AE:  INCF   32,F
00AF:  MOVF   30,W
00B0:  ADDWF  31,F
00B1:  GOTO   0E4
00B2:  MOVF   2F,W
00B3:  SUBWF  32,F
00B4:  BTFSC  03.0
00B5:  GOTO   0CD
00B6:  MOVLW  01
00B7:  SUBWF  33,F
00B8:  BTFSC  03.0
00B9:  GOTO   0CD
00BA:  SUBWF  34,F
00BB:  BTFSC  03.0
00BC:  GOTO   0CD
00BD:  INCF   34,F
00BE:  INCF   33,F
00BF:  MOVF   2F,W
00C0:  ADDWF  32,F
00C1:  MOVF   30,W
00C2:  ADDWF  31,F
00C3:  BTFSS  03.0
00C4:  GOTO   0E4
00C5:  INCF   32,F
00C6:  BTFSS  03.2
00C7:  GOTO   0E4
00C8:  INCF   33,F
00C9:  BTFSS  03.2
00CA:  GOTO   0E4
00CB:  INCF   34,F
00CC:  GOTO   0E4
00CD:  MOVF   2E,W
00CE:  IORLW  80
00CF:  SUBWF  33,F
00D0:  BTFSC  03.0
00D1:  GOTO   0E3
00D2:  MOVLW  01
00D3:  SUBWF  34,F
00D4:  BTFSC  03.0
00D5:  GOTO   0E3
00D6:  INCF   34,F
00D7:  MOVF   2E,W
00D8:  IORLW  80
00D9:  ADDWF  33,F
00DA:  MOVF   2F,W
00DB:  ADDWF  32,F
00DC:  BTFSS  03.0
00DD:  GOTO   0C1
00DE:  INCF   33,F
00DF:  BTFSS  03.2
00E0:  GOTO   0C1
00E1:  INCF   34,F
00E2:  GOTO   0C1
00E3:  BSF    7A.0
00E4:  DECFSZ 35,F
00E5:  GOTO   0E7
00E6:  GOTO   0F2
00E7:  BCF    03.0
00E8:  RLF    31,F
00E9:  RLF    32,F
00EA:  RLF    33,F
00EB:  RLF    34,F
00EC:  BCF    03.0
00ED:  RLF    7A,F
00EE:  RLF    79,F
00EF:  RLF    78,F
00F0:  RLF    36,F
00F1:  GOTO   09E
00F2:  BTFSS  36.0
00F3:  GOTO   0FA
00F4:  BCF    03.0
00F5:  RRF    78,F
00F6:  RRF    79,F
00F7:  RRF    7A,F
00F8:  RRF    36,F
00F9:  GOTO   0FD
00FA:  DECF   77,F
00FB:  BTFSC  03.2
00FC:  GOTO   13F
00FD:  BTFSC  36.7
00FE:  GOTO   126
00FF:  BCF    03.0
0100:  RLF    31,F
0101:  RLF    32,F
0102:  RLF    33,F
0103:  RLF    34,F
0104:  MOVF   30,W
0105:  SUBWF  31,F
0106:  BTFSC  03.0
0107:  GOTO   112
0108:  MOVLW  01
0109:  SUBWF  32,F
010A:  BTFSC  03.0
010B:  GOTO   112
010C:  SUBWF  33,F
010D:  BTFSC  03.0
010E:  GOTO   112
010F:  SUBWF  34,F
0110:  BTFSS  03.0
0111:  GOTO   135
0112:  MOVF   2F,W
0113:  SUBWF  32,F
0114:  BTFSC  03.0
0115:  GOTO   11D
0116:  MOVLW  01
0117:  SUBWF  33,F
0118:  BTFSC  03.0
0119:  GOTO   11D
011A:  SUBWF  34,F
011B:  BTFSS  03.0
011C:  GOTO   135
011D:  MOVF   2E,W
011E:  IORLW  80
011F:  SUBWF  33,F
0120:  BTFSC  03.0
0121:  GOTO   126
0122:  MOVLW  01
0123:  SUBWF  34,F
0124:  BTFSS  03.0
0125:  GOTO   135
0126:  INCF   7A,F
0127:  BTFSS  03.2
0128:  GOTO   135
0129:  INCF   79,F
012A:  BTFSS  03.2
012B:  GOTO   135
012C:  INCF   78,F
012D:  BTFSS  03.2
012E:  GOTO   135
012F:  INCF   77,F
0130:  BTFSC  03.2
0131:  GOTO   13F
0132:  RRF    78,F
0133:  RRF    79,F
0134:  RRF    7A,F
0135:  MOVF   2A,W
0136:  MOVWF  35
0137:  MOVF   2E,W
0138:  XORWF  35,F
0139:  BTFSS  35.7
013A:  GOTO   13D
013B:  BSF    78.7
013C:  GOTO   143
013D:  BCF    78.7
013E:  GOTO   143
013F:  CLRF   77
0140:  CLRF   78
0141:  CLRF   79
0142:  CLRF   7A
0143:  BCF    03.5
0144:  RETURN
0145:  BSF    03.5
0146:  MOVF   30,W
0147:  BTFSC  03.2
0148:  GOTO   1B6
0149:  MOVWF  38
014A:  MOVF   34,W
014B:  BTFSC  03.2
014C:  GOTO   1B6
014D:  ADDWF  38,F
014E:  BTFSC  03.0
014F:  GOTO   157
0150:  MOVLW  7F
0151:  SUBWF  38,F
0152:  BTFSS  03.0
0153:  GOTO   1B6
0154:  BTFSC  03.2
0155:  GOTO   1B6
0156:  GOTO   15B
0157:  MOVLW  81
0158:  ADDWF  38,F
0159:  BTFSC  03.0
015A:  GOTO   1B6
015B:  MOVF   38,W
015C:  MOVWF  77
015D:  CLRF   78
015E:  CLRF   79
015F:  CLRF   7A
0160:  MOVF   31,W
0161:  MOVWF  3C
0162:  BSF    3C.7
0163:  MOVF   32,W
0164:  MOVWF  3B
0165:  MOVF   33,W
0166:  MOVWF  3A
0167:  MOVLW  18
0168:  MOVWF  38
0169:  CLRF   39
016A:  BTFSS  3A.0
016B:  GOTO   184
016C:  MOVF   37,W
016D:  ADDWF  7A,F
016E:  BTFSS  03.0
016F:  GOTO   176
0170:  INCF   79,F
0171:  BTFSS  03.2
0172:  GOTO   176
0173:  INCF   78,F
0174:  BTFSC  03.2
0175:  BSF    39.7
0176:  MOVF   36,W
0177:  ADDWF  79,F
0178:  BTFSS  03.0
0179:  GOTO   17D
017A:  INCF   78,F
017B:  BTFSC  03.2
017C:  BSF    39.7
017D:  MOVF   35,W
017E:  MOVWF  32
017F:  BSF    32.7
0180:  MOVF   32,W
0181:  ADDWF  78,F
0182:  BTFSC  03.0
0183:  BSF    39.7
0184:  RLF    39,F
0185:  RRF    78,F
0186:  RRF    79,F
0187:  RRF    7A,F
0188:  RRF    3C,F
0189:  RRF    3B,F
018A:  RRF    3A,F
018B:  BCF    03.0
018C:  DECFSZ 38,F
018D:  GOTO   169
018E:  MOVLW  01
018F:  ADDWF  77,F
0190:  BTFSC  03.0
0191:  GOTO   1B6
0192:  BTFSC  78.7
0193:  GOTO   19B
0194:  RLF    3C,F
0195:  RLF    7A,F
0196:  RLF    79,F
0197:  RLF    78,F
0198:  DECF   77,F
0199:  BTFSC  03.2
019A:  GOTO   1B6
019B:  BTFSS  3C.7
019C:  GOTO   1AC
019D:  INCF   7A,F
019E:  BTFSS  03.2
019F:  GOTO   1AC
01A0:  INCF   79,F
01A1:  BTFSS  03.2
01A2:  GOTO   1AC
01A3:  INCF   78,F
01A4:  BTFSS  03.2
01A5:  GOTO   1AC
01A6:  RRF    78,F
01A7:  RRF    79,F
01A8:  RRF    7A,F
01A9:  INCF   77,F
01AA:  BTFSC  03.2
01AB:  GOTO   1B6
01AC:  MOVF   31,W
01AD:  MOVWF  39
01AE:  MOVF   35,W
01AF:  XORWF  39,F
01B0:  BTFSS  39.7
01B1:  GOTO   1B4
01B2:  BSF    78.7
01B3:  GOTO   1BA
01B4:  BCF    78.7
01B5:  GOTO   1BA
01B6:  CLRF   77
01B7:  CLRF   78
01B8:  CLRF   79
01B9:  CLRF   7A
01BA:  BCF    03.5
01BB:  RETURN
01BC:  MOVLW  80
01BD:  BTFSS  03.1
01BE:  GOTO   1C2
01BF:  BSF    03.5
01C0:  XORWF  39,F
01C1:  BCF    03.5
01C2:  BSF    03.5
01C3:  CLRF   3E
01C4:  CLRF   3F
01C5:  MOVF   35,W
01C6:  MOVWF  3D
01C7:  MOVF   39,W
01C8:  XORWF  3D,F
01C9:  MOVF   34,W
01CA:  BTFSC  03.2
01CB:  GOTO   2B0
01CC:  MOVWF  3C
01CD:  MOVWF  77
01CE:  MOVF   38,W
01CF:  BTFSC  03.2
01D0:  GOTO   2B9
01D1:  SUBWF  3C,F
01D2:  BTFSC  03.2
01D3:  GOTO   255
01D4:  BTFSS  03.0
01D5:  GOTO   213
01D6:  MOVF   39,W
01D7:  MOVWF  42
01D8:  BSF    42.7
01D9:  MOVF   3A,W
01DA:  MOVWF  41
01DB:  MOVF   3B,W
01DC:  MOVWF  40
01DD:  CLRF   3F
01DE:  BCF    03.0
01DF:  RRF    42,F
01E0:  RRF    41,F
01E1:  RRF    40,F
01E2:  RRF    3F,F
01E3:  DECFSZ 3C,F
01E4:  GOTO   1DD
01E5:  BTFSS  3D.7
01E6:  GOTO   1EA
01E7:  BSF    3E.0
01E8:  GOTO   2CD
01E9:  BCF    3E.0
01EA:  BCF    3C.0
01EB:  BSF    3E.4
01EC:  MOVLW  B7
01ED:  MOVWF  04
01EE:  BCF    03.7
01EF:  GOTO   2E2
01F0:  BCF    3E.4
01F1:  BTFSC  3D.7
01F2:  GOTO   1FD
01F3:  BTFSS  3C.0
01F4:  GOTO   208
01F5:  RRF    42,F
01F6:  RRF    41,F
01F7:  RRF    40,F
01F8:  RRF    3F,F
01F9:  INCF   77,F
01FA:  BTFSC  03.2
01FB:  GOTO   2C8
01FC:  GOTO   208
01FD:  BTFSC  42.7
01FE:  GOTO   20B
01FF:  BCF    03.0
0200:  RLF    3F,F
0201:  RLF    40,F
0202:  RLF    41,F
0203:  RLF    42,F
0204:  DECF   77,F
0205:  BTFSC  03.2
0206:  GOTO   2C8
0207:  GOTO   1FD
0208:  BSF    3E.6
0209:  GOTO   275
020A:  BCF    3E.6
020B:  MOVF   35,W
020C:  MOVWF  3D
020D:  BTFSS  3D.7
020E:  GOTO   211
020F:  BSF    42.7
0210:  GOTO   2C1
0211:  BCF    42.7
0212:  GOTO   2C1
0213:  MOVF   38,W
0214:  MOVWF  3C
0215:  MOVWF  77
0216:  MOVF   34,W
0217:  SUBWF  3C,F
0218:  MOVF   35,W
0219:  MOVWF  42
021A:  BSF    42.7
021B:  MOVF   36,W
021C:  MOVWF  41
021D:  MOVF   37,W
021E:  MOVWF  40
021F:  CLRF   3F
0220:  BCF    03.0
0221:  RRF    42,F
0222:  RRF    41,F
0223:  RRF    40,F
0224:  RRF    3F,F
0225:  DECFSZ 3C,F
0226:  GOTO   21F
0227:  BTFSS  3D.7
0228:  GOTO   22C
0229:  BSF    3E.1
022A:  GOTO   2CD
022B:  BCF    3E.1
022C:  BCF    3C.0
022D:  BSF    3E.5
022E:  MOVLW  BB
022F:  MOVWF  04
0230:  BCF    03.7
0231:  GOTO   2E2
0232:  BCF    3E.5
0233:  BTFSC  3D.7
0234:  GOTO   23F
0235:  BTFSS  3C.0
0236:  GOTO   24A
0237:  RRF    42,F
0238:  RRF    41,F
0239:  RRF    40,F
023A:  RRF    3F,F
023B:  INCF   77,F
023C:  BTFSC  03.2
023D:  GOTO   2C8
023E:  GOTO   24A
023F:  BTFSC  42.7
0240:  GOTO   24D
0241:  BCF    03.0
0242:  RLF    3F,F
0243:  RLF    40,F
0244:  RLF    41,F
0245:  RLF    42,F
0246:  DECF   77,F
0247:  BTFSC  03.2
0248:  GOTO   2C8
0249:  GOTO   23F
024A:  BSF    3E.7
024B:  GOTO   275
024C:  BCF    3E.7
024D:  MOVF   39,W
024E:  MOVWF  3D
024F:  BTFSS  3D.7
0250:  GOTO   253
0251:  BSF    42.7
0252:  GOTO   2C1
0253:  BCF    42.7
0254:  GOTO   2C1
0255:  MOVF   39,W
0256:  MOVWF  42
0257:  BSF    42.7
0258:  MOVF   3A,W
0259:  MOVWF  41
025A:  MOVF   3B,W
025B:  MOVWF  40
025C:  BTFSS  3D.7
025D:  GOTO   262
025E:  BCF    42.7
025F:  BSF    3E.2
0260:  GOTO   2CD
0261:  BCF    3E.2
0262:  CLRF   3F
0263:  BCF    3C.0
0264:  MOVLW  B7
0265:  MOVWF  04
0266:  BCF    03.7
0267:  GOTO   2E2
0268:  BTFSC  3D.7
0269:  GOTO   28B
026A:  MOVF   35,W
026B:  MOVWF  3D
026C:  BTFSS  3C.0
026D:  GOTO   275
026E:  RRF    42,F
026F:  RRF    41,F
0270:  RRF    40,F
0271:  RRF    3F,F
0272:  INCF   77,F
0273:  BTFSC  03.2
0274:  GOTO   2C8
0275:  BTFSS  3F.7
0276:  GOTO   286
0277:  INCF   40,F
0278:  BTFSS  03.2
0279:  GOTO   286
027A:  INCF   41,F
027B:  BTFSS  03.2
027C:  GOTO   286
027D:  INCF   42,F
027E:  BTFSS  03.2
027F:  GOTO   286
0280:  RRF    42,F
0281:  RRF    41,F
0282:  RRF    40,F
0283:  INCF   77,F
0284:  BTFSC  03.2
0285:  GOTO   2C8
0286:  BTFSC  3E.6
0287:  GOTO   20A
0288:  BTFSC  3E.7
0289:  GOTO   24C
028A:  GOTO   2AA
028B:  MOVLW  80
028C:  XORWF  42,F
028D:  BTFSS  42.7
028E:  GOTO   293
028F:  GOTO   2CD
0290:  MOVF   39,W
0291:  MOVWF  3D
0292:  GOTO   2A0
0293:  MOVF   35,W
0294:  MOVWF  3D
0295:  MOVF   42,F
0296:  BTFSS  03.2
0297:  GOTO   2A0
0298:  MOVF   41,F
0299:  BTFSS  03.2
029A:  GOTO   2A0
029B:  MOVF   40,F
029C:  BTFSS  03.2
029D:  GOTO   2A0
029E:  CLRF   77
029F:  GOTO   2C1
02A0:  BTFSC  42.7
02A1:  GOTO   2AA
02A2:  BCF    03.0
02A3:  RLF    3F,F
02A4:  RLF    40,F
02A5:  RLF    41,F
02A6:  RLF    42,F
02A7:  DECFSZ 77,F
02A8:  GOTO   2A0
02A9:  GOTO   2C8
02AA:  BTFSS  3D.7
02AB:  GOTO   2AE
02AC:  BSF    42.7
02AD:  GOTO   2C1
02AE:  BCF    42.7
02AF:  GOTO   2C1
02B0:  MOVF   38,W
02B1:  MOVWF  77
02B2:  MOVF   39,W
02B3:  MOVWF  42
02B4:  MOVF   3A,W
02B5:  MOVWF  41
02B6:  MOVF   3B,W
02B7:  MOVWF  40
02B8:  GOTO   2C1
02B9:  MOVF   34,W
02BA:  MOVWF  77
02BB:  MOVF   35,W
02BC:  MOVWF  42
02BD:  MOVF   36,W
02BE:  MOVWF  41
02BF:  MOVF   37,W
02C0:  MOVWF  40
02C1:  MOVF   42,W
02C2:  MOVWF  78
02C3:  MOVF   41,W
02C4:  MOVWF  79
02C5:  MOVF   40,W
02C6:  MOVWF  7A
02C7:  GOTO   300
02C8:  CLRF   77
02C9:  CLRF   78
02CA:  CLRF   79
02CB:  CLRF   7A
02CC:  GOTO   300
02CD:  CLRF   3F
02CE:  COMF   40,F
02CF:  COMF   41,F
02D0:  COMF   42,F
02D1:  COMF   3F,F
02D2:  INCF   3F,F
02D3:  BTFSS  03.2
02D4:  GOTO   2DB
02D5:  INCF   40,F
02D6:  BTFSS  03.2
02D7:  GOTO   2DB
02D8:  INCF   41,F
02D9:  BTFSC  03.2
02DA:  INCF   42,F
02DB:  BTFSC  3E.0
02DC:  GOTO   1E9
02DD:  BTFSC  3E.1
02DE:  GOTO   22B
02DF:  BTFSC  3E.2
02E0:  GOTO   261
02E1:  GOTO   290
02E2:  MOVF   00,W
02E3:  ADDWF  40,F
02E4:  BTFSS  03.0
02E5:  GOTO   2EC
02E6:  INCF   41,F
02E7:  BTFSS  03.2
02E8:  GOTO   2EC
02E9:  INCF   42,F
02EA:  BTFSC  03.2
02EB:  BSF    3C.0
02EC:  DECF   04,F
02ED:  MOVF   00,W
02EE:  ADDWF  41,F
02EF:  BTFSS  03.0
02F0:  GOTO   2F4
02F1:  INCF   42,F
02F2:  BTFSC  03.2
02F3:  BSF    3C.0
02F4:  DECF   04,F
02F5:  MOVF   00,W
02F6:  BTFSS  00.7
02F7:  XORLW  80
02F8:  ADDWF  42,F
02F9:  BTFSC  03.0
02FA:  BSF    3C.0
02FB:  BTFSC  3E.4
02FC:  GOTO   1F0
02FD:  BTFSC  3E.5
02FE:  GOTO   232
02FF:  GOTO   268
0300:  BCF    03.5
0301:  RETURN
0302:  BTFSC  03.1
0303:  GOTO   307
0304:  MOVLW  6E
0305:  MOVWF  04
0306:  BCF    03.7
0307:  CLRF   77
0308:  CLRF   78
0309:  CLRF   79
030A:  CLRF   7A
030B:  CLRF   6E
030C:  CLRF   6F
030D:  CLRF   70
030E:  CLRF   71
030F:  MOVF   6D,W
0310:  IORWF  6C,W
0311:  IORWF  6B,W
0312:  IORWF  6A,W
0313:  BTFSC  03.2
0314:  GOTO   345
0315:  MOVLW  20
0316:  MOVWF  72
0317:  BCF    03.0
0318:  RLF    66,F
0319:  RLF    67,F
031A:  RLF    68,F
031B:  RLF    69,F
031C:  RLF    6E,F
031D:  RLF    6F,F
031E:  RLF    70,F
031F:  RLF    71,F
0320:  MOVF   6D,W
0321:  SUBWF  71,W
0322:  BTFSS  03.2
0323:  GOTO   32E
0324:  MOVF   6C,W
0325:  SUBWF  70,W
0326:  BTFSS  03.2
0327:  GOTO   32E
0328:  MOVF   6B,W
0329:  SUBWF  6F,W
032A:  BTFSS  03.2
032B:  GOTO   32E
032C:  MOVF   6A,W
032D:  SUBWF  6E,W
032E:  BTFSS  03.0
032F:  GOTO   33F
0330:  MOVF   6A,W
0331:  SUBWF  6E,F
0332:  MOVF   6B,W
0333:  BTFSS  03.0
0334:  INCFSZ 6B,W
0335:  SUBWF  6F,F
0336:  MOVF   6C,W
0337:  BTFSS  03.0
0338:  INCFSZ 6C,W
0339:  SUBWF  70,F
033A:  MOVF   6D,W
033B:  BTFSS  03.0
033C:  INCFSZ 6D,W
033D:  SUBWF  71,F
033E:  BSF    03.0
033F:  RLF    77,F
0340:  RLF    78,F
0341:  RLF    79,F
0342:  RLF    7A,F
0343:  DECFSZ 72,F
0344:  GOTO   317
0345:  MOVF   6E,W
0346:  MOVWF  00
0347:  INCF   04,F
0348:  MOVF   6F,W
0349:  MOVWF  00
034A:  INCF   04,F
034B:  MOVF   70,W
034C:  MOVWF  00
034D:  INCF   04,F
034E:  MOVF   71,W
034F:  MOVWF  00
0350:  RETURN
0351:  MOVF   04,W
0352:  MOVWF  5E
0353:  MOVF   5D,W
0354:  MOVWF  60
0355:  BTFSC  03.2
0356:  GOTO   378
0357:  MOVF   5C,W
0358:  BSF    03.5
0359:  MOVWF  33
035A:  BCF    03.5
035B:  MOVF   5B,W
035C:  BSF    03.5
035D:  MOVWF  32
035E:  BCF    03.5
035F:  MOVF   5A,W
0360:  BSF    03.5
0361:  MOVWF  31
0362:  BCF    03.5
0363:  MOVF   59,W
0364:  BSF    03.5
0365:  MOVWF  30
0366:  CLRF   37
0367:  CLRF   36
0368:  MOVLW  20
0369:  MOVWF  35
036A:  MOVLW  82
036B:  MOVWF  34
036C:  BCF    03.5
036D:  CALL   145
036E:  MOVF   7A,W
036F:  MOVWF  5C
0370:  MOVF   79,W
0371:  MOVWF  5B
0372:  MOVF   78,W
0373:  MOVWF  5A
0374:  MOVF   77,W
0375:  MOVWF  59
0376:  DECFSZ 60,F
0377:  GOTO   357
0378:  MOVF   5C,W
0379:  MOVWF  69
037A:  MOVF   5B,W
037B:  MOVWF  68
037C:  MOVF   5A,W
037D:  MOVWF  67
037E:  MOVF   59,W
037F:  MOVWF  66
0380:  MOVF   66,W
0381:  SUBLW  B6
0382:  MOVWF  66
0383:  CLRF   7A
0384:  MOVF   67,W
0385:  MOVWF  6A
0386:  BSF    67.7
0387:  BCF    03.0
0388:  RRF    67,F
0389:  RRF    68,F
038A:  RRF    69,F
038B:  RRF    7A,F
038C:  RRF    79,F
038D:  RRF    78,F
038E:  RRF    77,F
038F:  DECFSZ 66,F
0390:  GOTO   387
0391:  BTFSS  6A.7
0392:  GOTO   39E
0393:  COMF   77,F
0394:  COMF   78,F
0395:  COMF   79,F
0396:  COMF   7A,F
0397:  INCF   77,F
0398:  BTFSC  03.2
0399:  INCF   78,F
039A:  BTFSC  03.2
039B:  INCF   79,F
039C:  BTFSC  03.2
039D:  INCF   7A,F
039E:  MOVF   7A,W
039F:  MOVWF  5C
03A0:  MOVF   79,W
03A1:  MOVWF  5B
03A2:  MOVF   78,W
03A3:  MOVWF  5A
03A4:  MOVF   77,W
03A5:  MOVWF  59
03A6:  BTFSS  5C.7
03A7:  GOTO   3B5
03A8:  DECF   5E,F
03A9:  BSF    5E.5
03AA:  COMF   59,F
03AB:  COMF   5A,F
03AC:  COMF   5B,F
03AD:  COMF   5C,F
03AE:  INCF   59,F
03AF:  BTFSC  03.2
03B0:  INCF   5A,F
03B1:  BTFSC  03.2
03B2:  INCF   5B,F
03B3:  BTFSC  03.2
03B4:  INCF   5C,F
03B5:  MOVLW  3B
03B6:  MOVWF  65
03B7:  MOVLW  9A
03B8:  MOVWF  64
03B9:  MOVLW  CA
03BA:  MOVWF  63
03BB:  CLRF   62
03BC:  MOVLW  0A
03BD:  MOVWF  60
03BE:  MOVF   5D,W
03BF:  BTFSC  03.2
03C0:  INCF   5E,F
03C1:  BSF    03.1
03C2:  MOVLW  59
03C3:  MOVWF  04
03C4:  BCF    03.7
03C5:  MOVF   5C,W
03C6:  MOVWF  69
03C7:  MOVF   5B,W
03C8:  MOVWF  68
03C9:  MOVF   5A,W
03CA:  MOVWF  67
03CB:  MOVF   59,W
03CC:  MOVWF  66
03CD:  MOVF   65,W
03CE:  MOVWF  6D
03CF:  MOVF   64,W
03D0:  MOVWF  6C
03D1:  MOVF   63,W
03D2:  MOVWF  6B
03D3:  MOVF   62,W
03D4:  MOVWF  6A
03D5:  CALL   302
03D6:  MOVF   78,W
03D7:  MOVF   77,F
03D8:  BTFSS  03.2
03D9:  GOTO   3ED
03DA:  INCF   5D,W
03DB:  SUBWF  60,W
03DC:  BTFSC  03.2
03DD:  GOTO   3ED
03DE:  MOVF   5E,W
03DF:  BTFSC  03.2
03E0:  GOTO   3EF
03E1:  ANDLW  0F
03E2:  SUBWF  60,W
03E3:  BTFSC  03.2
03E4:  GOTO   3E7
03E5:  BTFSC  03.0
03E6:  GOTO   423
03E7:  BTFSC  5E.7
03E8:  GOTO   423
03E9:  BTFSC  5E.6
03EA:  GOTO   3EF
03EB:  MOVLW  20
03EC:  GOTO   41E
03ED:  MOVLW  20
03EE:  ANDWF  5E,F
03EF:  BTFSS  5E.5
03F0:  GOTO   3FE
03F1:  BCF    5E.5
03F2:  MOVF   5D,W
03F3:  BTFSS  03.2
03F4:  DECF   5E,F
03F5:  MOVF   77,W
03F6:  MOVWF  5E
03F7:  MOVLW  2D
03F8:  BTFSS  0C.4
03F9:  GOTO   3F8
03FA:  MOVWF  19
03FB:  MOVF   5E,W
03FC:  MOVWF  77
03FD:  CLRF   5E
03FE:  MOVF   5D,W
03FF:  SUBWF  60,W
0400:  BTFSS  03.2
0401:  GOTO   40D
0402:  MOVF   77,W
0403:  MOVWF  5E
0404:  MOVLW  2E
0405:  BTFSS  0C.4
0406:  GOTO   405
0407:  MOVWF  19
0408:  MOVF   5E,W
0409:  MOVWF  77
040A:  MOVLW  20
040B:  ANDWF  5E,F
040C:  MOVLW  00
040D:  MOVLW  30
040E:  BTFSS  5E.5
040F:  GOTO   41E
0410:  BCF    5E.5
0411:  MOVF   5D,W
0412:  BTFSS  03.2
0413:  DECF   5E,F
0414:  MOVF   77,W
0415:  MOVWF  5E
0416:  MOVLW  2D
0417:  BTFSS  0C.4
0418:  GOTO   417
0419:  MOVWF  19
041A:  MOVF   5E,W
041B:  MOVWF  77
041C:  CLRF   5E
041D:  MOVLW  30
041E:  ADDWF  77,F
041F:  MOVF   77,W
0420:  BTFSS  0C.4
0421:  GOTO   420
0422:  MOVWF  19
0423:  BCF    03.1
0424:  MOVF   65,W
0425:  MOVWF  69
0426:  MOVF   64,W
0427:  MOVWF  68
0428:  MOVF   63,W
0429:  MOVWF  67
042A:  MOVF   62,W
042B:  MOVWF  66
042C:  CLRF   6D
042D:  CLRF   6C
042E:  CLRF   6B
042F:  MOVLW  0A
0430:  MOVWF  6A
0431:  CALL   302
0432:  MOVF   7A,W
0433:  MOVWF  65
0434:  MOVF   79,W
0435:  MOVWF  64
0436:  MOVF   78,W
0437:  MOVWF  63
0438:  MOVF   77,W
0439:  MOVWF  62
043A:  DECFSZ 60,F
043B:  GOTO   3C1
043C:  RETURN
043D:  MOVLW  8E
043E:  MOVWF  77
043F:  BSF    03.5
0440:  MOVF   30,W
0441:  SUBWF  77,F
0442:  MOVF   31,W
0443:  MOVWF  79
0444:  MOVF   32,W
0445:  MOVWF  78
0446:  BSF    79.7
0447:  MOVF   77,F
0448:  BTFSC  03.2
0449:  GOTO   455
044A:  BCF    03.0
044B:  MOVF   79,F
044C:  BTFSS  03.2
044D:  GOTO   451
044E:  MOVF   78,F
044F:  BTFSC  03.2
0450:  GOTO   455
0451:  RRF    79,F
0452:  RRF    78,F
0453:  DECFSZ 77,F
0454:  GOTO   44A
0455:  BTFSS  31.7
0456:  GOTO   45C
0457:  COMF   78,F
0458:  COMF   79,F
0459:  INCF   78,F
045A:  BTFSC  03.2
045B:  INCF   79,F
045C:  BCF    03.5
045D:  RETURN
*
073B:  MOVLW  8E
073C:  MOVWF  77
073D:  BSF    03.5
073E:  MOVF   27,W
073F:  MOVWF  78
0740:  MOVF   26,W
0741:  MOVWF  79
0742:  CLRF   7A
0743:  BTFSS  27.7
0744:  GOTO   74A
0745:  COMF   78,F
0746:  COMF   79,F
0747:  INCF   79,F
0748:  BTFSC  03.2
0749:  INCF   78,F
074A:  MOVF   78,F
074B:  BTFSS  03.2
074C:  GOTO   757
074D:  MOVF   79,W
074E:  MOVWF  78
074F:  CLRF   79
0750:  MOVLW  08
0751:  SUBWF  77,F
0752:  MOVF   78,F
0753:  BTFSS  03.2
0754:  GOTO   757
0755:  CLRF   77
0756:  GOTO   760
0757:  BCF    03.0
0758:  BTFSC  78.7
0759:  GOTO   75E
075A:  RLF    79,F
075B:  RLF    78,F
075C:  DECF   77,F
075D:  GOTO   757
075E:  BTFSS  27.7
075F:  BCF    78.7
0760:  BCF    03.5
0761:  RETURN
....................  
.................... #list 
....................  
.................... #device adc=10 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
102B:  BCF    03.5
102C:  CLRF   20
102D:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
045E:  BSF    03.5
045F:  BCF    2F.0
....................    y = x; 
0460:  MOVF   23,W
0461:  MOVWF  28
0462:  MOVF   22,W
0463:  MOVWF  27
0464:  MOVF   21,W
0465:  MOVWF  26
0466:  MOVF   20,W
0467:  MOVWF  25
....................  
....................    if (x < 0) 
0468:  MOVF   23,W
0469:  MOVWF  33
046A:  MOVF   22,W
046B:  MOVWF  32
046C:  MOVF   21,W
046D:  MOVWF  31
046E:  MOVF   20,W
046F:  MOVWF  30
0470:  CLRF   37
0471:  CLRF   36
0472:  CLRF   35
0473:  CLRF   34
0474:  BCF    03.5
0475:  CALL   038
0476:  BTFSS  03.0
0477:  GOTO   47E
....................    { 
....................       s = 1; 
0478:  BSF    03.5
0479:  BSF    2F.0
....................       y = -y; 
047A:  MOVF   26,W
047B:  XORLW  80
047C:  MOVWF  26
047D:  BCF    03.5
....................    } 
....................  
....................    if (y <= 32768.0) 
047E:  BSF    03.5
047F:  MOVF   28,W
0480:  MOVWF  33
0481:  MOVF   27,W
0482:  MOVWF  32
0483:  MOVF   26,W
0484:  MOVWF  31
0485:  MOVF   25,W
0486:  MOVWF  30
0487:  CLRF   37
0488:  CLRF   36
0489:  CLRF   35
048A:  MOVLW  8E
048B:  MOVWF  34
048C:  BCF    03.5
048D:  CALL   038
048E:  BTFSC  03.0
048F:  GOTO   492
0490:  BTFSS  03.2
0491:  GOTO   4AF
....................       res = (float32)(unsigned int16)y; 
0492:  BSF    03.5
0493:  MOVF   28,W
0494:  MOVWF  33
0495:  MOVF   27,W
0496:  MOVWF  32
0497:  MOVF   26,W
0498:  MOVWF  31
0499:  MOVF   25,W
049A:  MOVWF  30
049B:  BCF    03.5
049C:  CALL   43D
049D:  MOVF   79,W
049E:  BSF    03.5
049F:  MOVWF  35
04A0:  MOVF   78,W
04A1:  MOVWF  34
04A2:  BCF    03.5
04A3:  CALL   019
04A4:  MOVF   7A,W
04A5:  BSF    03.5
04A6:  MOVWF  2C
04A7:  MOVF   79,W
04A8:  MOVWF  2B
04A9:  MOVF   78,W
04AA:  MOVWF  2A
04AB:  MOVF   77,W
04AC:  MOVWF  29
04AD:  GOTO   587
04AE:  BCF    03.5
....................  
....................  else if (y < 10000000.0) 
04AF:  BSF    03.5
04B0:  MOVF   28,W
04B1:  MOVWF  33
04B2:  MOVF   27,W
04B3:  MOVWF  32
04B4:  MOVF   26,W
04B5:  MOVWF  31
04B6:  MOVF   25,W
04B7:  MOVWF  30
04B8:  MOVLW  80
04B9:  MOVWF  37
04BA:  MOVLW  96
04BB:  MOVWF  36
04BC:  MOVLW  18
04BD:  MOVWF  35
04BE:  MOVLW  96
04BF:  MOVWF  34
04C0:  BCF    03.5
04C1:  CALL   038
04C2:  BTFSS  03.0
04C3:  GOTO   57E
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
04C4:  BSF    03.5
04C5:  MOVF   28,W
04C6:  MOVWF  33
04C7:  MOVF   27,W
04C8:  MOVWF  32
04C9:  MOVF   26,W
04CA:  MOVWF  31
04CB:  MOVF   25,W
04CC:  MOVWF  30
04CD:  CLRF   37
04CE:  CLRF   36
04CF:  CLRF   35
04D0:  MOVLW  70
04D1:  MOVWF  34
04D2:  BCF    03.5
04D3:  CALL   145
04D4:  MOVF   7A,W
04D5:  BSF    03.5
04D6:  MOVWF  33
04D7:  MOVF   79,W
04D8:  MOVWF  32
04D9:  MOVF   78,W
04DA:  MOVWF  31
04DB:  MOVF   77,W
04DC:  MOVWF  30
04DD:  BCF    03.5
04DE:  CALL   43D
04DF:  MOVF   79,W
04E0:  BSF    03.5
04E1:  MOVWF  2E
04E2:  MOVF   78,W
04E3:  MOVWF  2D
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
04E4:  MOVF   28,W
04E5:  MOVWF  33
04E6:  MOVF   27,W
04E7:  MOVWF  32
04E8:  MOVF   26,W
04E9:  MOVWF  31
04EA:  MOVF   25,W
04EB:  MOVWF  30
04EC:  CLRF   37
04ED:  CLRF   36
04EE:  CLRF   35
04EF:  MOVLW  70
04F0:  MOVWF  34
04F1:  BCF    03.5
04F2:  CALL   145
04F3:  MOVF   7A,W
04F4:  BSF    03.5
04F5:  MOVWF  33
04F6:  MOVF   79,W
04F7:  MOVWF  32
04F8:  MOVF   78,W
04F9:  MOVWF  31
04FA:  MOVF   77,W
04FB:  MOVWF  30
04FC:  MOVF   2E,W
04FD:  MOVWF  35
04FE:  MOVF   2D,W
04FF:  MOVWF  34
0500:  BCF    03.5
0501:  CALL   019
0502:  BSF    03.1
0503:  BSF    03.5
0504:  MOVF   33,W
0505:  MOVWF  37
0506:  MOVF   32,W
0507:  MOVWF  36
0508:  MOVF   31,W
0509:  MOVWF  35
050A:  MOVF   30,W
050B:  MOVWF  34
050C:  MOVF   7A,W
050D:  MOVWF  3B
050E:  MOVF   79,W
050F:  MOVWF  3A
0510:  MOVF   78,W
0511:  MOVWF  39
0512:  MOVF   77,W
0513:  MOVWF  38
0514:  BCF    03.5
0515:  CALL   1BC
0516:  BSF    03.5
0517:  CLRF   33
0518:  CLRF   32
0519:  CLRF   31
051A:  MOVLW  8E
051B:  MOVWF  30
051C:  MOVF   7A,W
051D:  MOVWF  37
051E:  MOVF   79,W
051F:  MOVWF  36
0520:  MOVF   78,W
0521:  MOVWF  35
0522:  MOVF   77,W
0523:  MOVWF  34
0524:  BCF    03.5
0525:  CALL   145
0526:  MOVF   7A,W
0527:  BSF    03.5
0528:  MOVWF  28
0529:  MOVF   79,W
052A:  MOVWF  27
052B:  MOVF   78,W
052C:  MOVWF  26
052D:  MOVF   77,W
052E:  MOVWF  25
....................       res = 32768.0*(float32)l; 
052F:  MOVF   2E,W
0530:  MOVWF  35
0531:  MOVF   2D,W
0532:  MOVWF  34
0533:  BCF    03.5
0534:  CALL   019
0535:  BSF    03.5
0536:  CLRF   33
0537:  CLRF   32
0538:  CLRF   31
0539:  MOVLW  8E
053A:  MOVWF  30
053B:  MOVF   7A,W
053C:  MOVWF  37
053D:  MOVF   79,W
053E:  MOVWF  36
053F:  MOVF   78,W
0540:  MOVWF  35
0541:  MOVF   77,W
0542:  MOVWF  34
0543:  BCF    03.5
0544:  CALL   145
0545:  MOVF   7A,W
0546:  BSF    03.5
0547:  MOVWF  2C
0548:  MOVF   79,W
0549:  MOVWF  2B
054A:  MOVF   78,W
054B:  MOVWF  2A
054C:  MOVF   77,W
054D:  MOVWF  29
....................       res += (float32)(unsigned int16)y; 
054E:  MOVF   28,W
054F:  MOVWF  33
0550:  MOVF   27,W
0551:  MOVWF  32
0552:  MOVF   26,W
0553:  MOVWF  31
0554:  MOVF   25,W
0555:  MOVWF  30
0556:  BCF    03.5
0557:  CALL   43D
0558:  MOVF   79,W
0559:  BSF    03.5
055A:  MOVWF  35
055B:  MOVF   78,W
055C:  MOVWF  34
055D:  BCF    03.5
055E:  CALL   019
055F:  BCF    03.1
0560:  BSF    03.5
0561:  MOVF   2C,W
0562:  MOVWF  37
0563:  MOVF   2B,W
0564:  MOVWF  36
0565:  MOVF   2A,W
0566:  MOVWF  35
0567:  MOVF   29,W
0568:  MOVWF  34
0569:  MOVF   7A,W
056A:  MOVWF  3B
056B:  MOVF   79,W
056C:  MOVWF  3A
056D:  MOVF   78,W
056E:  MOVWF  39
056F:  MOVF   77,W
0570:  MOVWF  38
0571:  BCF    03.5
0572:  CALL   1BC
0573:  MOVF   7A,W
0574:  BSF    03.5
0575:  MOVWF  2C
0576:  MOVF   79,W
0577:  MOVWF  2B
0578:  MOVF   78,W
0579:  MOVWF  2A
057A:  MOVF   77,W
057B:  MOVWF  29
....................    } 
057C:  GOTO   587
057D:  BCF    03.5
....................  
....................  else 
....................   res = y; 
057E:  BSF    03.5
057F:  MOVF   28,W
0580:  MOVWF  2C
0581:  MOVF   27,W
0582:  MOVWF  2B
0583:  MOVF   26,W
0584:  MOVWF  2A
0585:  MOVF   25,W
0586:  MOVWF  29
....................  
....................  y = y - (float32)(unsigned int16)y; 
0587:  MOVF   28,W
0588:  MOVWF  33
0589:  MOVF   27,W
058A:  MOVWF  32
058B:  MOVF   26,W
058C:  MOVWF  31
058D:  MOVF   25,W
058E:  MOVWF  30
058F:  BCF    03.5
0590:  CALL   43D
0591:  MOVF   79,W
0592:  BSF    03.5
0593:  MOVWF  35
0594:  MOVF   78,W
0595:  MOVWF  34
0596:  BCF    03.5
0597:  CALL   019
0598:  BSF    03.1
0599:  BSF    03.5
059A:  MOVF   28,W
059B:  MOVWF  37
059C:  MOVF   27,W
059D:  MOVWF  36
059E:  MOVF   26,W
059F:  MOVWF  35
05A0:  MOVF   25,W
05A1:  MOVWF  34
05A2:  MOVF   7A,W
05A3:  MOVWF  3B
05A4:  MOVF   79,W
05A5:  MOVWF  3A
05A6:  MOVF   78,W
05A7:  MOVWF  39
05A8:  MOVF   77,W
05A9:  MOVWF  38
05AA:  BCF    03.5
05AB:  CALL   1BC
05AC:  MOVF   7A,W
05AD:  BSF    03.5
05AE:  MOVWF  28
05AF:  MOVF   79,W
05B0:  MOVWF  27
05B1:  MOVF   78,W
05B2:  MOVWF  26
05B3:  MOVF   77,W
05B4:  MOVWF  25
....................  
....................  if (s) 
05B5:  BTFSS  2F.0
05B6:  GOTO   5BA
....................   res = -res; 
05B7:  MOVF   2A,W
05B8:  XORLW  80
05B9:  MOVWF  2A
....................  
....................  if (y != 0) 
05BA:  MOVF   28,W
05BB:  MOVWF  33
05BC:  MOVF   27,W
05BD:  MOVWF  32
05BE:  MOVF   26,W
05BF:  MOVWF  31
05C0:  MOVF   25,W
05C1:  MOVWF  30
05C2:  CLRF   37
05C3:  CLRF   36
05C4:  CLRF   35
05C5:  CLRF   34
05C6:  BCF    03.5
05C7:  CALL   038
05C8:  BTFSC  03.2
05C9:  GOTO   607
....................  { 
....................   if (s == 1 && n == 0) 
05CA:  BSF    03.5
05CB:  BTFSS  2F.0
05CC:  GOTO   5E9
05CD:  MOVF   24,F
05CE:  BTFSS  03.2
05CF:  GOTO   5E9
....................    res -= 1.0; 
05D0:  BSF    03.1
05D1:  MOVF   2C,W
05D2:  MOVWF  37
05D3:  MOVF   2B,W
05D4:  MOVWF  36
05D5:  MOVF   2A,W
05D6:  MOVWF  35
05D7:  MOVF   29,W
05D8:  MOVWF  34
05D9:  CLRF   3B
05DA:  CLRF   3A
05DB:  CLRF   39
05DC:  MOVLW  7F
05DD:  MOVWF  38
05DE:  BCF    03.5
05DF:  CALL   1BC
05E0:  MOVF   7A,W
05E1:  BSF    03.5
05E2:  MOVWF  2C
05E3:  MOVF   79,W
05E4:  MOVWF  2B
05E5:  MOVF   78,W
05E6:  MOVWF  2A
05E7:  MOVF   77,W
05E8:  MOVWF  29
....................  
....................   if (s == 0 && n == 1) 
05E9:  BTFSC  2F.0
05EA:  GOTO   606
05EB:  DECFSZ 24,W
05EC:  GOTO   606
....................    res += 1.0; 
05ED:  BCF    03.1
05EE:  MOVF   2C,W
05EF:  MOVWF  37
05F0:  MOVF   2B,W
05F1:  MOVWF  36
05F2:  MOVF   2A,W
05F3:  MOVWF  35
05F4:  MOVF   29,W
05F5:  MOVWF  34
05F6:  CLRF   3B
05F7:  CLRF   3A
05F8:  CLRF   39
05F9:  MOVLW  7F
05FA:  MOVWF  38
05FB:  BCF    03.5
05FC:  CALL   1BC
05FD:  MOVF   7A,W
05FE:  BSF    03.5
05FF:  MOVWF  2C
0600:  MOVF   79,W
0601:  MOVWF  2B
0602:  MOVF   78,W
0603:  MOVWF  2A
0604:  MOVF   77,W
0605:  MOVWF  29
0606:  BCF    03.5
....................  } 
....................  if (x == 0) 
0607:  BSF    03.5
0608:  MOVF   23,W
0609:  MOVWF  33
060A:  MOVF   22,W
060B:  MOVWF  32
060C:  MOVF   21,W
060D:  MOVWF  31
060E:  MOVF   20,W
060F:  MOVWF  30
0610:  CLRF   37
0611:  CLRF   36
0612:  CLRF   35
0613:  CLRF   34
0614:  BCF    03.5
0615:  CALL   038
0616:  BTFSS  03.2
0617:  GOTO   61E
....................     res = 0; 
0618:  BSF    03.5
0619:  CLRF   2C
061A:  CLRF   2B
061B:  CLRF   2A
061C:  CLRF   29
061D:  BCF    03.5
....................  
....................  return (res); 
061E:  BSF    03.5
061F:  MOVF   29,W
0620:  MOVWF  77
0621:  MOVF   2A,W
0622:  MOVWF  78
0623:  MOVF   2B,W
0624:  MOVWF  79
0625:  MOVF   2C,W
0626:  MOVWF  7A
0627:  BCF    03.5
0628:  RETURN
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
06EA:  MOVF   7E,W
06EB:  BSF    03.5
06EC:  MOVWF  23
06ED:  MOVF   7D,W
06EE:  MOVWF  22
06EF:  MOVF   7C,W
06F0:  MOVWF  21
06F1:  MOVF   7B,W
06F2:  MOVWF  20
06F3:  CLRF   24
06F4:  BCF    03.5
06F5:  CALL   45E
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
06AB:  MOVF   7E,W
06AC:  BSF    03.5
06AD:  MOVWF  23
06AE:  MOVF   7D,W
06AF:  MOVWF  22
06B0:  MOVF   7C,W
06B1:  MOVWF  21
06B2:  MOVF   7B,W
06B3:  MOVWF  20
06B4:  MOVLW  01
06B5:  MOVWF  24
06B6:  BCF    03.5
06B7:  CALL   45E
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0629:  MOVF   6C,W
062A:  BSF    03.5
062B:  MOVWF  33
062C:  BCF    03.5
062D:  MOVF   6B,W
062E:  BSF    03.5
062F:  MOVWF  32
0630:  BCF    03.5
0631:  MOVF   6A,W
0632:  BSF    03.5
0633:  MOVWF  31
0634:  BCF    03.5
0635:  MOVF   69,W
0636:  BSF    03.5
0637:  MOVWF  30
0638:  CLRF   37
0639:  CLRF   36
063A:  CLRF   35
063B:  CLRF   34
063C:  BCF    03.5
063D:  CALL   038
063E:  BTFSC  03.2
063F:  GOTO   73A
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
0640:  MOVF   68,W
0641:  BSF    03.5
0642:  MOVWF  2C
0643:  BCF    03.5
0644:  MOVF   67,W
0645:  BSF    03.5
0646:  MOVWF  2B
0647:  BCF    03.5
0648:  MOVF   66,W
0649:  BSF    03.5
064A:  MOVWF  2A
064B:  BCF    03.5
064C:  MOVF   65,W
064D:  BSF    03.5
064E:  MOVWF  29
064F:  BCF    03.5
0650:  MOVF   6C,W
0651:  BSF    03.5
0652:  MOVWF  30
0653:  BCF    03.5
0654:  MOVF   6B,W
0655:  BSF    03.5
0656:  MOVWF  2F
0657:  BCF    03.5
0658:  MOVF   6A,W
0659:  BSF    03.5
065A:  MOVWF  2E
065B:  BCF    03.5
065C:  MOVF   69,W
065D:  BSF    03.5
065E:  MOVWF  2D
065F:  BCF    03.5
0660:  CALL   079
0661:  MOVF   7A,W
0662:  MOVWF  74
0663:  MOVF   79,W
0664:  MOVWF  73
0665:  MOVF   78,W
0666:  MOVWF  72
0667:  MOVF   77,W
0668:  MOVWF  71
0669:  MOVF   74,W
066A:  BSF    03.5
066B:  MOVWF  33
066C:  MOVF   73,W
066D:  MOVWF  32
066E:  MOVF   72,W
066F:  MOVWF  31
0670:  MOVF   71,W
0671:  MOVWF  30
0672:  CLRF   37
0673:  CLRF   36
0674:  CLRF   35
0675:  CLRF   34
0676:  BCF    03.5
0677:  CALL   038
0678:  BTFSS  03.0
0679:  GOTO   6B9
067A:  MOVF   68,W
067B:  BSF    03.5
067C:  MOVWF  2C
067D:  BCF    03.5
067E:  MOVF   67,W
067F:  BSF    03.5
0680:  MOVWF  2B
0681:  BCF    03.5
0682:  MOVF   66,W
0683:  BSF    03.5
0684:  MOVWF  2A
0685:  BCF    03.5
0686:  MOVF   65,W
0687:  BSF    03.5
0688:  MOVWF  29
0689:  BCF    03.5
068A:  MOVF   6C,W
068B:  BSF    03.5
068C:  MOVWF  30
068D:  BCF    03.5
068E:  MOVF   6B,W
068F:  BSF    03.5
0690:  MOVWF  2F
0691:  BCF    03.5
0692:  MOVF   6A,W
0693:  BSF    03.5
0694:  MOVWF  2E
0695:  BCF    03.5
0696:  MOVF   69,W
0697:  BSF    03.5
0698:  MOVWF  2D
0699:  BCF    03.5
069A:  CALL   079
069B:  MOVF   7A,W
069C:  MOVWF  74
069D:  MOVF   79,W
069E:  MOVWF  73
069F:  MOVF   78,W
06A0:  MOVWF  72
06A1:  MOVF   77,W
06A2:  MOVWF  71
06A3:  MOVF   74,W
06A4:  MOVWF  7E
06A5:  MOVF   73,W
06A6:  MOVWF  7D
06A7:  MOVF   72,W
06A8:  MOVWF  7C
06A9:  MOVF   71,W
06AA:  MOVWF  7B
*
06B8:  GOTO   6F6
06B9:  MOVF   68,W
06BA:  BSF    03.5
06BB:  MOVWF  2C
06BC:  BCF    03.5
06BD:  MOVF   67,W
06BE:  BSF    03.5
06BF:  MOVWF  2B
06C0:  BCF    03.5
06C1:  MOVF   66,W
06C2:  BSF    03.5
06C3:  MOVWF  2A
06C4:  BCF    03.5
06C5:  MOVF   65,W
06C6:  BSF    03.5
06C7:  MOVWF  29
06C8:  BCF    03.5
06C9:  MOVF   6C,W
06CA:  BSF    03.5
06CB:  MOVWF  30
06CC:  BCF    03.5
06CD:  MOVF   6B,W
06CE:  BSF    03.5
06CF:  MOVWF  2F
06D0:  BCF    03.5
06D1:  MOVF   6A,W
06D2:  BSF    03.5
06D3:  MOVWF  2E
06D4:  BCF    03.5
06D5:  MOVF   69,W
06D6:  BSF    03.5
06D7:  MOVWF  2D
06D8:  BCF    03.5
06D9:  CALL   079
06DA:  MOVF   7A,W
06DB:  MOVWF  74
06DC:  MOVF   79,W
06DD:  MOVWF  73
06DE:  MOVF   78,W
06DF:  MOVWF  72
06E0:  MOVF   77,W
06E1:  MOVWF  71
06E2:  MOVF   74,W
06E3:  MOVWF  7E
06E4:  MOVF   73,W
06E5:  MOVWF  7D
06E6:  MOVF   72,W
06E7:  MOVWF  7C
06E8:  MOVF   71,W
06E9:  MOVWF  7B
*
06F6:  MOVF   7A,W
06F7:  MOVWF  70
06F8:  MOVF   79,W
06F9:  MOVWF  6F
06FA:  MOVF   78,W
06FB:  MOVWF  6E
06FC:  MOVF   77,W
06FD:  MOVWF  6D
....................       return(x-(i*y)); 
06FE:  MOVF   70,W
06FF:  BSF    03.5
0700:  MOVWF  33
0701:  BCF    03.5
0702:  MOVF   6F,W
0703:  BSF    03.5
0704:  MOVWF  32
0705:  BCF    03.5
0706:  MOVF   6E,W
0707:  BSF    03.5
0708:  MOVWF  31
0709:  BCF    03.5
070A:  MOVF   6D,W
070B:  BSF    03.5
070C:  MOVWF  30
070D:  BCF    03.5
070E:  MOVF   6C,W
070F:  BSF    03.5
0710:  MOVWF  37
0711:  BCF    03.5
0712:  MOVF   6B,W
0713:  BSF    03.5
0714:  MOVWF  36
0715:  BCF    03.5
0716:  MOVF   6A,W
0717:  BSF    03.5
0718:  MOVWF  35
0719:  BCF    03.5
071A:  MOVF   69,W
071B:  BSF    03.5
071C:  MOVWF  34
071D:  BCF    03.5
071E:  CALL   145
071F:  BSF    03.1
0720:  MOVF   68,W
0721:  BSF    03.5
0722:  MOVWF  37
0723:  BCF    03.5
0724:  MOVF   67,W
0725:  BSF    03.5
0726:  MOVWF  36
0727:  BCF    03.5
0728:  MOVF   66,W
0729:  BSF    03.5
072A:  MOVWF  35
072B:  BCF    03.5
072C:  MOVF   65,W
072D:  BSF    03.5
072E:  MOVWF  34
072F:  MOVF   7A,W
0730:  MOVWF  3B
0731:  MOVF   79,W
0732:  MOVWF  3A
0733:  MOVF   78,W
0734:  MOVWF  39
0735:  MOVF   77,W
0736:  MOVWF  38
0737:  BCF    03.5
0738:  CALL   1BC
0739:  GOTO   73A
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
073A:  RETURN
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
*
0A0C:  MOVF   6C,W
0A0D:  BSF    03.5
0A0E:  MOVWF  33
0A0F:  BCF    03.5
0A10:  MOVF   6B,W
0A11:  BSF    03.5
0A12:  MOVWF  32
0A13:  BCF    03.5
0A14:  MOVF   6A,W
0A15:  BSF    03.5
0A16:  MOVWF  31
0A17:  BCF    03.5
0A18:  MOVF   69,W
0A19:  BSF    03.5
0A1A:  MOVWF  30
0A1B:  MOVLW  3B
0A1C:  MOVWF  37
0A1D:  MOVLW  AA
0A1E:  MOVWF  36
0A1F:  MOVLW  38
0A20:  MOVWF  35
0A21:  MOVLW  7F
0A22:  MOVWF  34
0A23:  BCF    0A.3
0A24:  BCF    03.5
0A25:  CALL   145
0A26:  BSF    0A.3
0A27:  MOVF   7A,W
0A28:  BSF    03.5
0A29:  MOVWF  33
0A2A:  MOVF   79,W
0A2B:  MOVWF  32
0A2C:  MOVF   78,W
0A2D:  MOVWF  31
0A2E:  MOVF   77,W
0A2F:  MOVWF  30
0A30:  BCF    0A.3
0A31:  BCF    03.5
0A32:  CALL   43D
0A33:  BSF    0A.3
0A34:  MOVF   78,W
0A35:  MOVWF  75
....................    s = 0; 
0A36:  BCF    76.0
....................    y = x; 
0A37:  MOVF   6C,W
0A38:  MOVWF  70
0A39:  MOVF   6B,W
0A3A:  MOVWF  6F
0A3B:  MOVF   6A,W
0A3C:  MOVWF  6E
0A3D:  MOVF   69,W
0A3E:  MOVWF  6D
....................  
....................    if (x < 0) 
0A3F:  MOVF   6C,W
0A40:  BSF    03.5
0A41:  MOVWF  33
0A42:  BCF    03.5
0A43:  MOVF   6B,W
0A44:  BSF    03.5
0A45:  MOVWF  32
0A46:  BCF    03.5
0A47:  MOVF   6A,W
0A48:  BSF    03.5
0A49:  MOVWF  31
0A4A:  BCF    03.5
0A4B:  MOVF   69,W
0A4C:  BSF    03.5
0A4D:  MOVWF  30
0A4E:  CLRF   37
0A4F:  CLRF   36
0A50:  CLRF   35
0A51:  CLRF   34
0A52:  BCF    0A.3
0A53:  BCF    03.5
0A54:  CALL   038
0A55:  BSF    0A.3
0A56:  BTFSS  03.0
0A57:  GOTO   25E
....................    { 
....................       s = 1; 
0A58:  BSF    76.0
....................       n = -n; 
0A59:  COMF   75,F
0A5A:  INCF   75,F
....................       y = -y; 
0A5B:  MOVF   6E,W
0A5C:  XORLW  80
0A5D:  MOVWF  6E
....................    } 
....................  
....................    res = 0.0; 
0A5E:  CLRF   74
0A5F:  CLRF   73
0A60:  CLRF   72
0A61:  CLRF   71
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
0A62:  BSF    03.5
0A63:  CLRF   21
0A64:  MOVLW  71
0A65:  MOVWF  20
0A66:  MOVF   20,W
0A67:  MOVWF  04
0A68:  BCF    03.7
0A69:  BTFSC  21.0
0A6A:  BSF    03.7
0A6B:  MOVLW  7F
0A6C:  ADDWF  75,W
0A6D:  MOVWF  00
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
0A6E:  MOVF   70,W
0A6F:  MOVWF  33
0A70:  BCF    03.5
0A71:  MOVF   6F,W
0A72:  BSF    03.5
0A73:  MOVWF  32
0A74:  BCF    03.5
0A75:  MOVF   6E,W
0A76:  BSF    03.5
0A77:  MOVWF  31
0A78:  BCF    03.5
0A79:  MOVF   6D,W
0A7A:  BSF    03.5
0A7B:  MOVWF  30
0A7C:  MOVLW  3B
0A7D:  MOVWF  37
0A7E:  MOVLW  AA
0A7F:  MOVWF  36
0A80:  MOVLW  38
0A81:  MOVWF  35
0A82:  MOVLW  7F
0A83:  MOVWF  34
0A84:  BCF    0A.3
0A85:  BCF    03.5
0A86:  CALL   145
0A87:  BSF    0A.3
0A88:  MOVF   7A,W
0A89:  BSF    03.5
0A8A:  MOVWF  23
0A8B:  MOVF   79,W
0A8C:  MOVWF  22
0A8D:  MOVF   78,W
0A8E:  MOVWF  21
0A8F:  MOVF   77,W
0A90:  MOVWF  20
0A91:  CLRF   27
0A92:  MOVF   75,W
0A93:  MOVWF  26
0A94:  BTFSC  26.7
0A95:  DECF   27,F
0A96:  BCF    0A.3
0A97:  BCF    03.5
0A98:  CALL   73B
0A99:  BSF    0A.3
0A9A:  BSF    03.1
0A9B:  BSF    03.5
0A9C:  MOVF   23,W
0A9D:  MOVWF  37
0A9E:  MOVF   22,W
0A9F:  MOVWF  36
0AA0:  MOVF   21,W
0AA1:  MOVWF  35
0AA2:  MOVF   20,W
0AA3:  MOVWF  34
0AA4:  MOVF   7A,W
0AA5:  MOVWF  3B
0AA6:  MOVF   79,W
0AA7:  MOVWF  3A
0AA8:  MOVF   78,W
0AA9:  MOVWF  39
0AAA:  MOVF   77,W
0AAB:  MOVWF  38
0AAC:  BCF    0A.3
0AAD:  BCF    03.5
0AAE:  CALL   1BC
0AAF:  BSF    0A.3
0AB0:  MOVF   7A,W
0AB1:  MOVWF  70
0AB2:  MOVF   79,W
0AB3:  MOVWF  6F
0AB4:  MOVF   78,W
0AB5:  MOVWF  6E
0AB6:  MOVF   77,W
0AB7:  MOVWF  6D
....................  
....................    r = pe[0]*y + pe[1]; 
0AB8:  MOVLW  7C
0AB9:  BSF    03.5
0ABA:  MOVWF  33
0ABB:  MOVLW  88
0ABC:  MOVWF  32
0ABD:  MOVLW  59
0ABE:  MOVWF  31
0ABF:  MOVLW  72
0AC0:  MOVWF  30
0AC1:  MOVF   70,W
0AC2:  MOVWF  37
0AC3:  BCF    03.5
0AC4:  MOVF   6F,W
0AC5:  BSF    03.5
0AC6:  MOVWF  36
0AC7:  BCF    03.5
0AC8:  MOVF   6E,W
0AC9:  BSF    03.5
0ACA:  MOVWF  35
0ACB:  BCF    03.5
0ACC:  MOVF   6D,W
0ACD:  BSF    03.5
0ACE:  MOVWF  34
0ACF:  BCF    0A.3
0AD0:  BCF    03.5
0AD1:  CALL   145
0AD2:  BSF    0A.3
0AD3:  MOVF   7A,W
0AD4:  BSF    03.5
0AD5:  MOVWF  23
0AD6:  MOVF   79,W
0AD7:  MOVWF  22
0AD8:  MOVF   78,W
0AD9:  MOVWF  21
0ADA:  MOVF   77,W
0ADB:  MOVWF  20
0ADC:  BCF    03.1
0ADD:  MOVF   23,W
0ADE:  MOVWF  37
0ADF:  MOVF   22,W
0AE0:  MOVWF  36
0AE1:  MOVF   21,W
0AE2:  MOVWF  35
0AE3:  MOVF   20,W
0AE4:  MOVWF  34
0AE5:  MOVLW  E0
0AE6:  MOVWF  3B
0AE7:  MOVLW  97
0AE8:  MOVWF  3A
0AE9:  MOVLW  26
0AEA:  MOVWF  39
0AEB:  MOVLW  75
0AEC:  MOVWF  38
0AED:  BCF    0A.3
0AEE:  BCF    03.5
0AEF:  CALL   1BC
0AF0:  BSF    0A.3
0AF1:  MOVF   7A,W
0AF2:  MOVWF  7E
0AF3:  MOVF   79,W
0AF4:  MOVWF  7D
0AF5:  MOVF   78,W
0AF6:  MOVWF  7C
0AF7:  MOVF   77,W
0AF8:  MOVWF  7B
....................    r = r*y + pe[2]; 
0AF9:  MOVF   7E,W
0AFA:  BSF    03.5
0AFB:  MOVWF  33
0AFC:  MOVF   7D,W
0AFD:  MOVWF  32
0AFE:  MOVF   7C,W
0AFF:  MOVWF  31
0B00:  MOVF   7B,W
0B01:  MOVWF  30
0B02:  MOVF   70,W
0B03:  MOVWF  37
0B04:  BCF    03.5
0B05:  MOVF   6F,W
0B06:  BSF    03.5
0B07:  MOVWF  36
0B08:  BCF    03.5
0B09:  MOVF   6E,W
0B0A:  BSF    03.5
0B0B:  MOVWF  35
0B0C:  BCF    03.5
0B0D:  MOVF   6D,W
0B0E:  BSF    03.5
0B0F:  MOVWF  34
0B10:  BCF    0A.3
0B11:  BCF    03.5
0B12:  CALL   145
0B13:  BSF    0A.3
0B14:  MOVF   7A,W
0B15:  BSF    03.5
0B16:  MOVWF  23
0B17:  MOVF   79,W
0B18:  MOVWF  22
0B19:  MOVF   78,W
0B1A:  MOVWF  21
0B1B:  MOVF   77,W
0B1C:  MOVWF  20
0B1D:  BCF    03.1
0B1E:  MOVF   23,W
0B1F:  MOVWF  37
0B20:  MOVF   22,W
0B21:  MOVWF  36
0B22:  MOVF   21,W
0B23:  MOVWF  35
0B24:  MOVF   20,W
0B25:  MOVWF  34
0B26:  MOVLW  C4
0B27:  MOVWF  3B
0B28:  MOVLW  1D
0B29:  MOVWF  3A
0B2A:  MOVLW  1E
0B2B:  MOVWF  39
0B2C:  MOVLW  78
0B2D:  MOVWF  38
0B2E:  BCF    0A.3
0B2F:  BCF    03.5
0B30:  CALL   1BC
0B31:  BSF    0A.3
0B32:  MOVF   7A,W
0B33:  MOVWF  7E
0B34:  MOVF   79,W
0B35:  MOVWF  7D
0B36:  MOVF   78,W
0B37:  MOVWF  7C
0B38:  MOVF   77,W
0B39:  MOVWF  7B
....................    r = r*y + pe[3]; 
0B3A:  MOVF   7E,W
0B3B:  BSF    03.5
0B3C:  MOVWF  33
0B3D:  MOVF   7D,W
0B3E:  MOVWF  32
0B3F:  MOVF   7C,W
0B40:  MOVWF  31
0B41:  MOVF   7B,W
0B42:  MOVWF  30
0B43:  MOVF   70,W
0B44:  MOVWF  37
0B45:  BCF    03.5
0B46:  MOVF   6F,W
0B47:  BSF    03.5
0B48:  MOVWF  36
0B49:  BCF    03.5
0B4A:  MOVF   6E,W
0B4B:  BSF    03.5
0B4C:  MOVWF  35
0B4D:  BCF    03.5
0B4E:  MOVF   6D,W
0B4F:  BSF    03.5
0B50:  MOVWF  34
0B51:  BCF    0A.3
0B52:  BCF    03.5
0B53:  CALL   145
0B54:  BSF    0A.3
0B55:  MOVF   7A,W
0B56:  BSF    03.5
0B57:  MOVWF  23
0B58:  MOVF   79,W
0B59:  MOVWF  22
0B5A:  MOVF   78,W
0B5B:  MOVWF  21
0B5C:  MOVF   77,W
0B5D:  MOVWF  20
0B5E:  BCF    03.1
0B5F:  MOVF   23,W
0B60:  MOVWF  37
0B61:  MOVF   22,W
0B62:  MOVWF  36
0B63:  MOVF   21,W
0B64:  MOVWF  35
0B65:  MOVF   20,W
0B66:  MOVWF  34
0B67:  MOVLW  5E
0B68:  MOVWF  3B
0B69:  MOVLW  50
0B6A:  MOVWF  3A
0B6B:  MOVLW  63
0B6C:  MOVWF  39
0B6D:  MOVLW  7A
0B6E:  MOVWF  38
0B6F:  BCF    0A.3
0B70:  BCF    03.5
0B71:  CALL   1BC
0B72:  BSF    0A.3
0B73:  MOVF   7A,W
0B74:  MOVWF  7E
0B75:  MOVF   79,W
0B76:  MOVWF  7D
0B77:  MOVF   78,W
0B78:  MOVWF  7C
0B79:  MOVF   77,W
0B7A:  MOVWF  7B
....................    r = r*y + pe[4]; 
0B7B:  MOVF   7E,W
0B7C:  BSF    03.5
0B7D:  MOVWF  33
0B7E:  MOVF   7D,W
0B7F:  MOVWF  32
0B80:  MOVF   7C,W
0B81:  MOVWF  31
0B82:  MOVF   7B,W
0B83:  MOVWF  30
0B84:  MOVF   70,W
0B85:  MOVWF  37
0B86:  BCF    03.5
0B87:  MOVF   6F,W
0B88:  BSF    03.5
0B89:  MOVWF  36
0B8A:  BCF    03.5
0B8B:  MOVF   6E,W
0B8C:  BSF    03.5
0B8D:  MOVWF  35
0B8E:  BCF    03.5
0B8F:  MOVF   6D,W
0B90:  BSF    03.5
0B91:  MOVWF  34
0B92:  BCF    0A.3
0B93:  BCF    03.5
0B94:  CALL   145
0B95:  BSF    0A.3
0B96:  MOVF   7A,W
0B97:  BSF    03.5
0B98:  MOVWF  23
0B99:  MOVF   79,W
0B9A:  MOVWF  22
0B9B:  MOVF   78,W
0B9C:  MOVWF  21
0B9D:  MOVF   77,W
0B9E:  MOVWF  20
0B9F:  BCF    03.1
0BA0:  MOVF   23,W
0BA1:  MOVWF  37
0BA2:  MOVF   22,W
0BA3:  MOVWF  36
0BA4:  MOVF   21,W
0BA5:  MOVWF  35
0BA6:  MOVF   20,W
0BA7:  MOVWF  34
0BA8:  MOVLW  1A
0BA9:  MOVWF  3B
0BAA:  MOVLW  FE
0BAB:  MOVWF  3A
0BAC:  MOVLW  75
0BAD:  MOVWF  39
0BAE:  MOVLW  7C
0BAF:  MOVWF  38
0BB0:  BCF    0A.3
0BB1:  BCF    03.5
0BB2:  CALL   1BC
0BB3:  BSF    0A.3
0BB4:  MOVF   7A,W
0BB5:  MOVWF  7E
0BB6:  MOVF   79,W
0BB7:  MOVWF  7D
0BB8:  MOVF   78,W
0BB9:  MOVWF  7C
0BBA:  MOVF   77,W
0BBB:  MOVWF  7B
....................    r = r*y + pe[5]; 
0BBC:  MOVF   7E,W
0BBD:  BSF    03.5
0BBE:  MOVWF  33
0BBF:  MOVF   7D,W
0BC0:  MOVWF  32
0BC1:  MOVF   7C,W
0BC2:  MOVWF  31
0BC3:  MOVF   7B,W
0BC4:  MOVWF  30
0BC5:  MOVF   70,W
0BC6:  MOVWF  37
0BC7:  BCF    03.5
0BC8:  MOVF   6F,W
0BC9:  BSF    03.5
0BCA:  MOVWF  36
0BCB:  BCF    03.5
0BCC:  MOVF   6E,W
0BCD:  BSF    03.5
0BCE:  MOVWF  35
0BCF:  BCF    03.5
0BD0:  MOVF   6D,W
0BD1:  BSF    03.5
0BD2:  MOVWF  34
0BD3:  BCF    0A.3
0BD4:  BCF    03.5
0BD5:  CALL   145
0BD6:  BSF    0A.3
0BD7:  MOVF   7A,W
0BD8:  BSF    03.5
0BD9:  MOVWF  23
0BDA:  MOVF   79,W
0BDB:  MOVWF  22
0BDC:  MOVF   78,W
0BDD:  MOVWF  21
0BDE:  MOVF   77,W
0BDF:  MOVWF  20
0BE0:  BCF    03.1
0BE1:  MOVF   23,W
0BE2:  MOVWF  37
0BE3:  MOVF   22,W
0BE4:  MOVWF  36
0BE5:  MOVF   21,W
0BE6:  MOVWF  35
0BE7:  MOVF   20,W
0BE8:  MOVWF  34
0BE9:  MOVLW  18
0BEA:  MOVWF  3B
0BEB:  MOVLW  72
0BEC:  MOVWF  3A
0BED:  MOVLW  31
0BEE:  MOVWF  39
0BEF:  MOVLW  7E
0BF0:  MOVWF  38
0BF1:  BCF    0A.3
0BF2:  BCF    03.5
0BF3:  CALL   1BC
0BF4:  BSF    0A.3
0BF5:  MOVF   7A,W
0BF6:  MOVWF  7E
0BF7:  MOVF   79,W
0BF8:  MOVWF  7D
0BF9:  MOVF   78,W
0BFA:  MOVWF  7C
0BFB:  MOVF   77,W
0BFC:  MOVWF  7B
....................  
....................    res = res*(1.0 + y*r); 
0BFD:  MOVF   70,W
0BFE:  BSF    03.5
0BFF:  MOVWF  33
0C00:  BCF    03.5
0C01:  MOVF   6F,W
0C02:  BSF    03.5
0C03:  MOVWF  32
0C04:  BCF    03.5
0C05:  MOVF   6E,W
0C06:  BSF    03.5
0C07:  MOVWF  31
0C08:  BCF    03.5
0C09:  MOVF   6D,W
0C0A:  BSF    03.5
0C0B:  MOVWF  30
0C0C:  MOVF   7E,W
0C0D:  MOVWF  37
0C0E:  MOVF   7D,W
0C0F:  MOVWF  36
0C10:  MOVF   7C,W
0C11:  MOVWF  35
0C12:  MOVF   7B,W
0C13:  MOVWF  34
0C14:  BCF    0A.3
0C15:  BCF    03.5
0C16:  CALL   145
0C17:  BSF    0A.3
0C18:  BCF    03.1
0C19:  BSF    03.5
0C1A:  CLRF   37
0C1B:  CLRF   36
0C1C:  CLRF   35
0C1D:  MOVLW  7F
0C1E:  MOVWF  34
0C1F:  MOVF   7A,W
0C20:  MOVWF  3B
0C21:  MOVF   79,W
0C22:  MOVWF  3A
0C23:  MOVF   78,W
0C24:  MOVWF  39
0C25:  MOVF   77,W
0C26:  MOVWF  38
0C27:  BCF    0A.3
0C28:  BCF    03.5
0C29:  CALL   1BC
0C2A:  BSF    0A.3
0C2B:  MOVF   74,W
0C2C:  BSF    03.5
0C2D:  MOVWF  33
0C2E:  MOVF   73,W
0C2F:  MOVWF  32
0C30:  MOVF   72,W
0C31:  MOVWF  31
0C32:  MOVF   71,W
0C33:  MOVWF  30
0C34:  MOVF   7A,W
0C35:  MOVWF  37
0C36:  MOVF   79,W
0C37:  MOVWF  36
0C38:  MOVF   78,W
0C39:  MOVWF  35
0C3A:  MOVF   77,W
0C3B:  MOVWF  34
0C3C:  BCF    0A.3
0C3D:  BCF    03.5
0C3E:  CALL   145
0C3F:  BSF    0A.3
0C40:  MOVF   7A,W
0C41:  MOVWF  74
0C42:  MOVF   79,W
0C43:  MOVWF  73
0C44:  MOVF   78,W
0C45:  MOVWF  72
0C46:  MOVF   77,W
0C47:  MOVWF  71
....................  
....................    if (s) 
0C48:  BTFSS  76.0
0C49:  GOTO   464
....................       res = 1.0/res; 
0C4A:  BSF    03.5
0C4B:  CLRF   2C
0C4C:  CLRF   2B
0C4D:  CLRF   2A
0C4E:  MOVLW  7F
0C4F:  MOVWF  29
0C50:  MOVF   74,W
0C51:  MOVWF  30
0C52:  MOVF   73,W
0C53:  MOVWF  2F
0C54:  MOVF   72,W
0C55:  MOVWF  2E
0C56:  MOVF   71,W
0C57:  MOVWF  2D
0C58:  BCF    0A.3
0C59:  BCF    03.5
0C5A:  CALL   079
0C5B:  BSF    0A.3
0C5C:  MOVF   7A,W
0C5D:  MOVWF  74
0C5E:  MOVF   79,W
0C5F:  MOVWF  73
0C60:  MOVF   78,W
0C61:  MOVWF  72
0C62:  MOVF   77,W
0C63:  MOVWF  71
....................    return(res); 
0C64:  MOVF   71,W
0C65:  MOVWF  77
0C66:  MOVF   72,W
0C67:  MOVWF  78
0C68:  MOVF   73,W
0C69:  MOVWF  79
0C6A:  MOVF   74,W
0C6B:  MOVWF  7A
0C6C:  RETURN
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
0800:  MOVF   6C,W
0801:  MOVWF  70
0802:  MOVF   6B,W
0803:  MOVWF  6F
0804:  MOVF   6A,W
0805:  MOVWF  6E
0806:  MOVF   69,W
0807:  MOVWF  6D
....................  
....................    if (y != 1.0) 
0808:  MOVF   70,W
0809:  BSF    03.5
080A:  MOVWF  33
080B:  BCF    03.5
080C:  MOVF   6F,W
080D:  BSF    03.5
080E:  MOVWF  32
080F:  BCF    03.5
0810:  MOVF   6E,W
0811:  BSF    03.5
0812:  MOVWF  31
0813:  BCF    03.5
0814:  MOVF   6D,W
0815:  BSF    03.5
0816:  MOVWF  30
0817:  CLRF   37
0818:  CLRF   36
0819:  CLRF   35
081A:  MOVLW  7F
081B:  MOVWF  34
081C:  BCF    0A.3
081D:  BCF    03.5
081E:  CALL   038
081F:  BSF    0A.3
0820:  BTFSC  03.2
0821:  GOTO   1FF
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
0822:  BSF    03.5
0823:  CLRF   25
0824:  MOVLW  6D
0825:  MOVWF  24
0826:  MOVF   24,W
0827:  MOVWF  04
0828:  BCF    03.7
0829:  BTFSC  25.0
082A:  BSF    03.7
082B:  MOVLW  7E
082C:  MOVWF  00
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
082D:  BSF    03.1
082E:  MOVF   70,W
082F:  MOVWF  37
0830:  BCF    03.5
0831:  MOVF   6F,W
0832:  BSF    03.5
0833:  MOVWF  36
0834:  BCF    03.5
0835:  MOVF   6E,W
0836:  BSF    03.5
0837:  MOVWF  35
0838:  BCF    03.5
0839:  MOVF   6D,W
083A:  BSF    03.5
083B:  MOVWF  34
083C:  CLRF   3B
083D:  CLRF   3A
083E:  CLRF   39
083F:  MOVLW  7F
0840:  MOVWF  38
0841:  BCF    0A.3
0842:  BCF    03.5
0843:  CALL   1BC
0844:  BSF    0A.3
0845:  MOVF   7A,W
0846:  BSF    03.5
0847:  MOVWF  27
0848:  MOVF   79,W
0849:  MOVWF  26
084A:  MOVF   78,W
084B:  MOVWF  25
084C:  MOVF   77,W
084D:  MOVWF  24
084E:  BCF    03.1
084F:  MOVF   70,W
0850:  MOVWF  37
0851:  BCF    03.5
0852:  MOVF   6F,W
0853:  BSF    03.5
0854:  MOVWF  36
0855:  BCF    03.5
0856:  MOVF   6E,W
0857:  BSF    03.5
0858:  MOVWF  35
0859:  BCF    03.5
085A:  MOVF   6D,W
085B:  BSF    03.5
085C:  MOVWF  34
085D:  CLRF   3B
085E:  CLRF   3A
085F:  CLRF   39
0860:  MOVLW  7F
0861:  MOVWF  38
0862:  BCF    0A.3
0863:  BCF    03.5
0864:  CALL   1BC
0865:  BSF    0A.3
0866:  BSF    03.5
0867:  MOVF   27,W
0868:  MOVWF  2C
0869:  MOVF   26,W
086A:  MOVWF  2B
086B:  MOVF   25,W
086C:  MOVWF  2A
086D:  MOVF   24,W
086E:  MOVWF  29
086F:  MOVF   7A,W
0870:  MOVWF  30
0871:  MOVF   79,W
0872:  MOVWF  2F
0873:  MOVF   78,W
0874:  MOVWF  2E
0875:  MOVF   77,W
0876:  MOVWF  2D
0877:  BCF    0A.3
0878:  BCF    03.5
0879:  CALL   079
087A:  BSF    0A.3
087B:  MOVF   7A,W
087C:  MOVWF  70
087D:  MOVF   79,W
087E:  MOVWF  6F
087F:  MOVF   78,W
0880:  MOVWF  6E
0881:  MOVF   77,W
0882:  MOVWF  6D
....................  
....................       y2=y*y; 
0883:  MOVF   70,W
0884:  BSF    03.5
0885:  MOVWF  33
0886:  BCF    03.5
0887:  MOVF   6F,W
0888:  BSF    03.5
0889:  MOVWF  32
088A:  BCF    03.5
088B:  MOVF   6E,W
088C:  BSF    03.5
088D:  MOVWF  31
088E:  BCF    03.5
088F:  MOVF   6D,W
0890:  BSF    03.5
0891:  MOVWF  30
0892:  MOVF   70,W
0893:  MOVWF  37
0894:  BCF    03.5
0895:  MOVF   6F,W
0896:  BSF    03.5
0897:  MOVWF  36
0898:  BCF    03.5
0899:  MOVF   6E,W
089A:  BSF    03.5
089B:  MOVWF  35
089C:  BCF    03.5
089D:  MOVF   6D,W
089E:  BSF    03.5
089F:  MOVWF  34
08A0:  BCF    0A.3
08A1:  BCF    03.5
08A2:  CALL   145
08A3:  BSF    0A.3
08A4:  MOVF   7A,W
08A5:  BSF    03.5
08A6:  MOVWF  23
08A7:  MOVF   79,W
08A8:  MOVWF  22
08A9:  MOVF   78,W
08AA:  MOVWF  21
08AB:  MOVF   77,W
08AC:  MOVWF  20
....................  
....................       res = pl[0]*y2 + pl[1]; 
08AD:  MOVLW  99
08AE:  MOVWF  33
08AF:  MOVLW  47
08B0:  MOVWF  32
08B1:  MOVLW  8A
08B2:  MOVWF  31
08B3:  MOVLW  7F
08B4:  MOVWF  30
08B5:  MOVF   23,W
08B6:  MOVWF  37
08B7:  MOVF   22,W
08B8:  MOVWF  36
08B9:  MOVF   21,W
08BA:  MOVWF  35
08BB:  MOVF   20,W
08BC:  MOVWF  34
08BD:  BCF    0A.3
08BE:  BCF    03.5
08BF:  CALL   145
08C0:  BSF    0A.3
08C1:  MOVF   7A,W
08C2:  BSF    03.5
08C3:  MOVWF  27
08C4:  MOVF   79,W
08C5:  MOVWF  26
08C6:  MOVF   78,W
08C7:  MOVWF  25
08C8:  MOVF   77,W
08C9:  MOVWF  24
08CA:  BCF    03.1
08CB:  MOVF   27,W
08CC:  MOVWF  37
08CD:  MOVF   26,W
08CE:  MOVWF  36
08CF:  MOVF   25,W
08D0:  MOVWF  35
08D1:  MOVF   24,W
08D2:  MOVWF  34
08D3:  CLRF   3B
08D4:  CLRF   3A
08D5:  CLRF   39
08D6:  MOVLW  80
08D7:  MOVWF  38
08D8:  BCF    0A.3
08D9:  BCF    03.5
08DA:  CALL   1BC
08DB:  BSF    0A.3
08DC:  MOVF   7A,W
08DD:  MOVWF  74
08DE:  MOVF   79,W
08DF:  MOVWF  73
08E0:  MOVF   78,W
08E1:  MOVWF  72
08E2:  MOVF   77,W
08E3:  MOVWF  71
....................  
....................       r = ql[0]*y2 + ql[1]; 
08E4:  MOVLW  4C
08E5:  BSF    03.5
08E6:  MOVWF  33
08E7:  MOVLW  F3
08E8:  MOVWF  32
08E9:  MOVLW  3A
08EA:  MOVWF  31
08EB:  MOVLW  7B
08EC:  MOVWF  30
08ED:  MOVF   23,W
08EE:  MOVWF  37
08EF:  MOVF   22,W
08F0:  MOVWF  36
08F1:  MOVF   21,W
08F2:  MOVWF  35
08F3:  MOVF   20,W
08F4:  MOVWF  34
08F5:  BCF    0A.3
08F6:  BCF    03.5
08F7:  CALL   145
08F8:  BSF    0A.3
08F9:  MOVF   7A,W
08FA:  BSF    03.5
08FB:  MOVWF  27
08FC:  MOVF   79,W
08FD:  MOVWF  26
08FE:  MOVF   78,W
08FF:  MOVWF  25
0900:  MOVF   77,W
0901:  MOVWF  24
0902:  BCF    03.1
0903:  MOVF   27,W
0904:  MOVWF  37
0905:  MOVF   26,W
0906:  MOVWF  36
0907:  MOVF   25,W
0908:  MOVWF  35
0909:  MOVF   24,W
090A:  MOVWF  34
090B:  MOVLW  2B
090C:  MOVWF  3B
090D:  MOVLW  9D
090E:  MOVWF  3A
090F:  MOVLW  DF
0910:  MOVWF  39
0911:  MOVLW  7E
0912:  MOVWF  38
0913:  BCF    0A.3
0914:  BCF    03.5
0915:  CALL   1BC
0916:  BSF    0A.3
0917:  MOVF   7A,W
0918:  MOVWF  7E
0919:  MOVF   79,W
091A:  MOVWF  7D
091B:  MOVF   78,W
091C:  MOVWF  7C
091D:  MOVF   77,W
091E:  MOVWF  7B
....................       r = r*y2 + 1.0; 
091F:  MOVF   7E,W
0920:  BSF    03.5
0921:  MOVWF  33
0922:  MOVF   7D,W
0923:  MOVWF  32
0924:  MOVF   7C,W
0925:  MOVWF  31
0926:  MOVF   7B,W
0927:  MOVWF  30
0928:  MOVF   23,W
0929:  MOVWF  37
092A:  MOVF   22,W
092B:  MOVWF  36
092C:  MOVF   21,W
092D:  MOVWF  35
092E:  MOVF   20,W
092F:  MOVWF  34
0930:  BCF    0A.3
0931:  BCF    03.5
0932:  CALL   145
0933:  BSF    0A.3
0934:  MOVF   7A,W
0935:  BSF    03.5
0936:  MOVWF  27
0937:  MOVF   79,W
0938:  MOVWF  26
0939:  MOVF   78,W
093A:  MOVWF  25
093B:  MOVF   77,W
093C:  MOVWF  24
093D:  BCF    03.1
093E:  MOVF   27,W
093F:  MOVWF  37
0940:  MOVF   26,W
0941:  MOVWF  36
0942:  MOVF   25,W
0943:  MOVWF  35
0944:  MOVF   24,W
0945:  MOVWF  34
0946:  CLRF   3B
0947:  CLRF   3A
0948:  CLRF   39
0949:  MOVLW  7F
094A:  MOVWF  38
094B:  BCF    0A.3
094C:  BCF    03.5
094D:  CALL   1BC
094E:  BSF    0A.3
094F:  MOVF   7A,W
0950:  MOVWF  7E
0951:  MOVF   79,W
0952:  MOVWF  7D
0953:  MOVF   78,W
0954:  MOVWF  7C
0955:  MOVF   77,W
0956:  MOVWF  7B
....................  
....................       res = y*res/r; 
0957:  MOVF   70,W
0958:  BSF    03.5
0959:  MOVWF  33
095A:  BCF    03.5
095B:  MOVF   6F,W
095C:  BSF    03.5
095D:  MOVWF  32
095E:  BCF    03.5
095F:  MOVF   6E,W
0960:  BSF    03.5
0961:  MOVWF  31
0962:  BCF    03.5
0963:  MOVF   6D,W
0964:  BSF    03.5
0965:  MOVWF  30
0966:  MOVF   74,W
0967:  MOVWF  37
0968:  MOVF   73,W
0969:  MOVWF  36
096A:  MOVF   72,W
096B:  MOVWF  35
096C:  MOVF   71,W
096D:  MOVWF  34
096E:  BCF    0A.3
096F:  BCF    03.5
0970:  CALL   145
0971:  BSF    0A.3
0972:  MOVF   7A,W
0973:  BSF    03.5
0974:  MOVWF  27
0975:  MOVF   79,W
0976:  MOVWF  26
0977:  MOVF   78,W
0978:  MOVWF  25
0979:  MOVF   77,W
097A:  MOVWF  24
097B:  MOVF   27,W
097C:  MOVWF  2C
097D:  MOVF   26,W
097E:  MOVWF  2B
097F:  MOVF   25,W
0980:  MOVWF  2A
0981:  MOVF   24,W
0982:  MOVWF  29
0983:  MOVF   7E,W
0984:  MOVWF  30
0985:  MOVF   7D,W
0986:  MOVWF  2F
0987:  MOVF   7C,W
0988:  MOVWF  2E
0989:  MOVF   7B,W
098A:  MOVWF  2D
098B:  BCF    0A.3
098C:  BCF    03.5
098D:  CALL   079
098E:  BSF    0A.3
098F:  MOVF   7A,W
0990:  MOVWF  74
0991:  MOVF   79,W
0992:  MOVWF  73
0993:  MOVF   78,W
0994:  MOVWF  72
0995:  MOVF   77,W
0996:  MOVWF  71
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
0997:  BSF    03.5
0998:  CLRF   25
0999:  MOVLW  69
099A:  MOVWF  24
099B:  MOVF   24,W
099C:  MOVWF  04
099D:  BCF    03.7
099E:  BTFSC  25.0
099F:  BSF    03.7
09A0:  MOVLW  7E
09A1:  SUBWF  00,W
09A2:  MOVWF  75
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
09A3:  BTFSS  75.7
09A4:  GOTO   1BA
....................          r = -(float32)-n; 
09A5:  MOVF   75,W
09A6:  SUBLW  00
09A7:  CLRF   27
09A8:  MOVWF  26
09A9:  BTFSC  26.7
09AA:  DECF   27,F
09AB:  BCF    0A.3
09AC:  BCF    03.5
09AD:  CALL   73B
09AE:  BSF    0A.3
09AF:  MOVF   77,W
09B0:  MOVWF  7B
09B1:  MOVF   78,W
09B2:  XORLW  80
09B3:  MOVWF  7C
09B4:  MOVF   79,W
09B5:  MOVWF  7D
09B6:  MOVF   7A,W
09B7:  MOVWF  7E
09B8:  GOTO   1CB
09B9:  BSF    03.5
....................       else 
....................          r = (float32)n; 
09BA:  CLRF   27
09BB:  MOVF   75,W
09BC:  MOVWF  26
09BD:  BTFSC  26.7
09BE:  DECF   27,F
09BF:  BCF    0A.3
09C0:  BCF    03.5
09C1:  CALL   73B
09C2:  BSF    0A.3
09C3:  MOVF   7A,W
09C4:  MOVWF  7E
09C5:  MOVF   79,W
09C6:  MOVWF  7D
09C7:  MOVF   78,W
09C8:  MOVWF  7C
09C9:  MOVF   77,W
09CA:  MOVWF  7B
....................  
....................       res += r*LN2; 
09CB:  MOVF   7E,W
09CC:  BSF    03.5
09CD:  MOVWF  33
09CE:  MOVF   7D,W
09CF:  MOVWF  32
09D0:  MOVF   7C,W
09D1:  MOVWF  31
09D2:  MOVF   7B,W
09D3:  MOVWF  30
09D4:  MOVLW  18
09D5:  MOVWF  37
09D6:  MOVLW  72
09D7:  MOVWF  36
09D8:  MOVLW  31
09D9:  MOVWF  35
09DA:  MOVLW  7E
09DB:  MOVWF  34
09DC:  BCF    0A.3
09DD:  BCF    03.5
09DE:  CALL   145
09DF:  BSF    0A.3
09E0:  BCF    03.1
09E1:  MOVF   74,W
09E2:  BSF    03.5
09E3:  MOVWF  37
09E4:  MOVF   73,W
09E5:  MOVWF  36
09E6:  MOVF   72,W
09E7:  MOVWF  35
09E8:  MOVF   71,W
09E9:  MOVWF  34
09EA:  MOVF   7A,W
09EB:  MOVWF  3B
09EC:  MOVF   79,W
09ED:  MOVWF  3A
09EE:  MOVF   78,W
09EF:  MOVWF  39
09F0:  MOVF   77,W
09F1:  MOVWF  38
09F2:  BCF    0A.3
09F3:  BCF    03.5
09F4:  CALL   1BC
09F5:  BSF    0A.3
09F6:  MOVF   7A,W
09F7:  MOVWF  74
09F8:  MOVF   79,W
09F9:  MOVWF  73
09FA:  MOVF   78,W
09FB:  MOVWF  72
09FC:  MOVF   77,W
09FD:  MOVWF  71
....................    } 
09FE:  GOTO   203
....................  
....................    else 
....................       res = 0.0; 
09FF:  CLRF   74
0A00:  CLRF   73
0A01:  CLRF   72
0A02:  CLRF   71
....................  
....................    return(res); 
0A03:  MOVF   71,W
0A04:  MOVWF  77
0A05:  MOVF   72,W
0A06:  MOVWF  78
0A07:  MOVF   73,W
0A08:  MOVWF  79
0A09:  MOVF   74,W
0A0A:  MOVWF  7A
0A0B:  RETURN
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
0C6D:  MOVF   60,W
0C6E:  BSF    03.5
0C6F:  MOVWF  33
0C70:  BCF    03.5
0C71:  MOVF   5F,W
0C72:  BSF    03.5
0C73:  MOVWF  32
0C74:  BCF    03.5
0C75:  MOVF   5E,W
0C76:  BSF    03.5
0C77:  MOVWF  31
0C78:  BCF    03.5
0C79:  MOVF   5D,W
0C7A:  BSF    03.5
0C7B:  MOVWF  30
0C7C:  CLRF   37
0C7D:  CLRF   36
0C7E:  CLRF   35
0C7F:  CLRF   34
0C80:  BCF    0A.3
0C81:  BCF    03.5
0C82:  CALL   038
0C83:  BSF    0A.3
0C84:  BTFSS  03.0
0C85:  GOTO   588
0C86:  MOVF   64,W
0C87:  MOVWF  68
0C88:  MOVF   63,W
0C89:  MOVWF  67
0C8A:  MOVF   62,W
0C8B:  MOVWF  66
0C8C:  MOVF   61,W
0C8D:  MOVWF  65
0C8E:  CLRF   6C
0C8F:  CLRF   6B
0C90:  CLRF   6A
0C91:  MOVLW  7F
0C92:  MOVWF  69
0C93:  BCF    0A.3
0C94:  CALL   629
0C95:  BSF    0A.3
0C96:  MOVF   7A,W
0C97:  MOVWF  68
0C98:  MOVF   79,W
0C99:  MOVWF  67
0C9A:  MOVF   78,W
0C9B:  MOVWF  66
0C9C:  MOVF   77,W
0C9D:  MOVWF  65
0C9E:  MOVF   68,W
0C9F:  BSF    03.5
0CA0:  MOVWF  33
0CA1:  BCF    03.5
0CA2:  MOVF   67,W
0CA3:  BSF    03.5
0CA4:  MOVWF  32
0CA5:  BCF    03.5
0CA6:  MOVF   66,W
0CA7:  BSF    03.5
0CA8:  MOVWF  31
0CA9:  BCF    03.5
0CAA:  MOVF   65,W
0CAB:  BSF    03.5
0CAC:  MOVWF  30
0CAD:  CLRF   37
0CAE:  CLRF   36
0CAF:  CLRF   35
0CB0:  CLRF   34
0CB1:  BCF    0A.3
0CB2:  BCF    03.5
0CB3:  CALL   038
0CB4:  BSF    0A.3
0CB5:  BTFSS  03.2
0CB6:  GOTO   588
....................       if(fmod(y, 2) == 0) { 
0CB7:  MOVF   64,W
0CB8:  MOVWF  68
0CB9:  MOVF   63,W
0CBA:  MOVWF  67
0CBB:  MOVF   62,W
0CBC:  MOVWF  66
0CBD:  MOVF   61,W
0CBE:  MOVWF  65
0CBF:  CLRF   6C
0CC0:  CLRF   6B
0CC1:  CLRF   6A
0CC2:  MOVLW  80
0CC3:  MOVWF  69
0CC4:  BCF    0A.3
0CC5:  CALL   629
0CC6:  BSF    0A.3
0CC7:  MOVF   7A,W
0CC8:  MOVWF  68
0CC9:  MOVF   79,W
0CCA:  MOVWF  67
0CCB:  MOVF   78,W
0CCC:  MOVWF  66
0CCD:  MOVF   77,W
0CCE:  MOVWF  65
0CCF:  MOVF   68,W
0CD0:  BSF    03.5
0CD1:  MOVWF  33
0CD2:  BCF    03.5
0CD3:  MOVF   67,W
0CD4:  BSF    03.5
0CD5:  MOVWF  32
0CD6:  BCF    03.5
0CD7:  MOVF   66,W
0CD8:  BSF    03.5
0CD9:  MOVWF  31
0CDA:  BCF    03.5
0CDB:  MOVF   65,W
0CDC:  BSF    03.5
0CDD:  MOVWF  30
0CDE:  CLRF   37
0CDF:  CLRF   36
0CE0:  CLRF   35
0CE1:  CLRF   34
0CE2:  BCF    0A.3
0CE3:  BCF    03.5
0CE4:  CALL   038
0CE5:  BSF    0A.3
0CE6:  BTFSS  03.2
0CE7:  GOTO   537
....................          return (exp(log(-x) * y)); 
0CE8:  MOVF   5D,W
0CE9:  MOVWF  65
0CEA:  MOVF   5E,W
0CEB:  XORLW  80
0CEC:  MOVWF  66
0CED:  MOVF   5F,W
0CEE:  MOVWF  67
0CEF:  MOVF   60,W
0CF0:  MOVWF  68
0CF1:  MOVWF  6C
0CF2:  MOVF   67,W
0CF3:  MOVWF  6B
0CF4:  MOVF   66,W
0CF5:  MOVWF  6A
0CF6:  MOVF   65,W
0CF7:  MOVWF  69
0CF8:  CALL   000
0CF9:  MOVF   7A,W
0CFA:  MOVWF  68
0CFB:  MOVF   79,W
0CFC:  MOVWF  67
0CFD:  MOVF   78,W
0CFE:  MOVWF  66
0CFF:  MOVF   77,W
0D00:  MOVWF  65
0D01:  MOVF   68,W
0D02:  BSF    03.5
0D03:  MOVWF  33
0D04:  BCF    03.5
0D05:  MOVF   67,W
0D06:  BSF    03.5
0D07:  MOVWF  32
0D08:  BCF    03.5
0D09:  MOVF   66,W
0D0A:  BSF    03.5
0D0B:  MOVWF  31
0D0C:  BCF    03.5
0D0D:  MOVF   65,W
0D0E:  BSF    03.5
0D0F:  MOVWF  30
0D10:  BCF    03.5
0D11:  MOVF   64,W
0D12:  BSF    03.5
0D13:  MOVWF  37
0D14:  BCF    03.5
0D15:  MOVF   63,W
0D16:  BSF    03.5
0D17:  MOVWF  36
0D18:  BCF    03.5
0D19:  MOVF   62,W
0D1A:  BSF    03.5
0D1B:  MOVWF  35
0D1C:  BCF    03.5
0D1D:  MOVF   61,W
0D1E:  BSF    03.5
0D1F:  MOVWF  34
0D20:  BCF    0A.3
0D21:  BCF    03.5
0D22:  CALL   145
0D23:  BSF    0A.3
0D24:  MOVF   7A,W
0D25:  MOVWF  68
0D26:  MOVF   79,W
0D27:  MOVWF  67
0D28:  MOVF   78,W
0D29:  MOVWF  66
0D2A:  MOVF   77,W
0D2B:  MOVWF  65
0D2C:  MOVF   68,W
0D2D:  MOVWF  6C
0D2E:  MOVF   67,W
0D2F:  MOVWF  6B
0D30:  MOVF   66,W
0D31:  MOVWF  6A
0D32:  MOVF   65,W
0D33:  MOVWF  69
0D34:  CALL   20C
0D35:  GOTO   651
....................       } else { 
0D36:  GOTO   587
....................          return (-exp(log(-x) * y)); 
0D37:  MOVF   5D,W
0D38:  MOVWF  65
0D39:  MOVF   5E,W
0D3A:  XORLW  80
0D3B:  MOVWF  66
0D3C:  MOVF   5F,W
0D3D:  MOVWF  67
0D3E:  MOVF   60,W
0D3F:  MOVWF  68
0D40:  MOVWF  6C
0D41:  MOVF   67,W
0D42:  MOVWF  6B
0D43:  MOVF   66,W
0D44:  MOVWF  6A
0D45:  MOVF   65,W
0D46:  MOVWF  69
0D47:  CALL   000
0D48:  MOVF   7A,W
0D49:  MOVWF  68
0D4A:  MOVF   79,W
0D4B:  MOVWF  67
0D4C:  MOVF   78,W
0D4D:  MOVWF  66
0D4E:  MOVF   77,W
0D4F:  MOVWF  65
0D50:  MOVF   68,W
0D51:  BSF    03.5
0D52:  MOVWF  33
0D53:  BCF    03.5
0D54:  MOVF   67,W
0D55:  BSF    03.5
0D56:  MOVWF  32
0D57:  BCF    03.5
0D58:  MOVF   66,W
0D59:  BSF    03.5
0D5A:  MOVWF  31
0D5B:  BCF    03.5
0D5C:  MOVF   65,W
0D5D:  BSF    03.5
0D5E:  MOVWF  30
0D5F:  BCF    03.5
0D60:  MOVF   64,W
0D61:  BSF    03.5
0D62:  MOVWF  37
0D63:  BCF    03.5
0D64:  MOVF   63,W
0D65:  BSF    03.5
0D66:  MOVWF  36
0D67:  BCF    03.5
0D68:  MOVF   62,W
0D69:  BSF    03.5
0D6A:  MOVWF  35
0D6B:  BCF    03.5
0D6C:  MOVF   61,W
0D6D:  BSF    03.5
0D6E:  MOVWF  34
0D6F:  BCF    0A.3
0D70:  BCF    03.5
0D71:  CALL   145
0D72:  BSF    0A.3
0D73:  MOVF   7A,W
0D74:  MOVWF  68
0D75:  MOVF   79,W
0D76:  MOVWF  67
0D77:  MOVF   78,W
0D78:  MOVWF  66
0D79:  MOVF   77,W
0D7A:  MOVWF  65
0D7B:  MOVF   68,W
0D7C:  MOVWF  6C
0D7D:  MOVF   67,W
0D7E:  MOVWF  6B
0D7F:  MOVF   66,W
0D80:  MOVWF  6A
0D81:  MOVF   65,W
0D82:  MOVWF  69
0D83:  CALL   20C
0D84:  MOVLW  80
0D85:  XORWF  78,F
0D86:  GOTO   651
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
0D87:  GOTO   651
0D88:  MOVF   60,W
0D89:  BSF    03.5
0D8A:  MOVWF  33
0D8B:  BCF    03.5
0D8C:  MOVF   5F,W
0D8D:  BSF    03.5
0D8E:  MOVWF  32
0D8F:  BCF    03.5
0D90:  MOVF   5E,W
0D91:  BSF    03.5
0D92:  MOVWF  31
0D93:  BCF    03.5
0D94:  MOVF   5D,W
0D95:  BSF    03.5
0D96:  MOVWF  30
0D97:  CLRF   37
0D98:  CLRF   36
0D99:  CLRF   35
0D9A:  CLRF   34
0D9B:  BCF    0A.3
0D9C:  BCF    03.5
0D9D:  CALL   038
0D9E:  BSF    0A.3
0D9F:  BTFSS  03.0
0DA0:  GOTO   5D8
0DA1:  MOVF   64,W
0DA2:  MOVWF  68
0DA3:  MOVF   63,W
0DA4:  MOVWF  67
0DA5:  MOVF   62,W
0DA6:  MOVWF  66
0DA7:  MOVF   61,W
0DA8:  MOVWF  65
0DA9:  CLRF   6C
0DAA:  CLRF   6B
0DAB:  CLRF   6A
0DAC:  MOVLW  7F
0DAD:  MOVWF  69
0DAE:  BCF    0A.3
0DAF:  CALL   629
0DB0:  BSF    0A.3
0DB1:  MOVF   7A,W
0DB2:  MOVWF  68
0DB3:  MOVF   79,W
0DB4:  MOVWF  67
0DB5:  MOVF   78,W
0DB6:  MOVWF  66
0DB7:  MOVF   77,W
0DB8:  MOVWF  65
0DB9:  MOVF   68,W
0DBA:  BSF    03.5
0DBB:  MOVWF  33
0DBC:  BCF    03.5
0DBD:  MOVF   67,W
0DBE:  BSF    03.5
0DBF:  MOVWF  32
0DC0:  BCF    03.5
0DC1:  MOVF   66,W
0DC2:  BSF    03.5
0DC3:  MOVWF  31
0DC4:  BCF    03.5
0DC5:  MOVF   65,W
0DC6:  BSF    03.5
0DC7:  MOVWF  30
0DC8:  CLRF   37
0DC9:  CLRF   36
0DCA:  CLRF   35
0DCB:  CLRF   34
0DCC:  BCF    0A.3
0DCD:  BCF    03.5
0DCE:  CALL   038
0DCF:  BSF    0A.3
0DD0:  BTFSC  03.2
0DD1:  GOTO   5D8
....................       return 0; 
0DD2:  CLRF   77
0DD3:  CLRF   78
0DD4:  CLRF   79
0DD5:  CLRF   7A
0DD6:  GOTO   651
....................    } else { 
0DD7:  GOTO   651
....................       if(x != 0 || 0 >= y) { 
0DD8:  MOVF   60,W
0DD9:  BSF    03.5
0DDA:  MOVWF  33
0DDB:  BCF    03.5
0DDC:  MOVF   5F,W
0DDD:  BSF    03.5
0DDE:  MOVWF  32
0DDF:  BCF    03.5
0DE0:  MOVF   5E,W
0DE1:  BSF    03.5
0DE2:  MOVWF  31
0DE3:  BCF    03.5
0DE4:  MOVF   5D,W
0DE5:  BSF    03.5
0DE6:  MOVWF  30
0DE7:  CLRF   37
0DE8:  CLRF   36
0DE9:  CLRF   35
0DEA:  CLRF   34
0DEB:  BCF    0A.3
0DEC:  BCF    03.5
0DED:  CALL   038
0DEE:  BSF    0A.3
0DEF:  BTFSS  03.2
0DF0:  GOTO   60C
0DF1:  MOVF   64,W
0DF2:  BSF    03.5
0DF3:  MOVWF  33
0DF4:  BCF    03.5
0DF5:  MOVF   63,W
0DF6:  BSF    03.5
0DF7:  MOVWF  32
0DF8:  BCF    03.5
0DF9:  MOVF   62,W
0DFA:  BSF    03.5
0DFB:  MOVWF  31
0DFC:  BCF    03.5
0DFD:  MOVF   61,W
0DFE:  BSF    03.5
0DFF:  MOVWF  30
0E00:  CLRF   37
0E01:  CLRF   36
0E02:  CLRF   35
0E03:  CLRF   34
0E04:  BCF    0A.3
0E05:  BCF    03.5
0E06:  CALL   038
0E07:  BSF    0A.3
0E08:  BTFSC  03.0
0E09:  GOTO   60C
0E0A:  BTFSS  03.2
0E0B:  GOTO   651
....................          return (exp(log(x) * y)); 
0E0C:  MOVF   60,W
0E0D:  MOVWF  6C
0E0E:  MOVF   5F,W
0E0F:  MOVWF  6B
0E10:  MOVF   5E,W
0E11:  MOVWF  6A
0E12:  MOVF   5D,W
0E13:  MOVWF  69
0E14:  CALL   000
0E15:  MOVF   7A,W
0E16:  MOVWF  68
0E17:  MOVF   79,W
0E18:  MOVWF  67
0E19:  MOVF   78,W
0E1A:  MOVWF  66
0E1B:  MOVF   77,W
0E1C:  MOVWF  65
0E1D:  MOVF   68,W
0E1E:  BSF    03.5
0E1F:  MOVWF  33
0E20:  BCF    03.5
0E21:  MOVF   67,W
0E22:  BSF    03.5
0E23:  MOVWF  32
0E24:  BCF    03.5
0E25:  MOVF   66,W
0E26:  BSF    03.5
0E27:  MOVWF  31
0E28:  BCF    03.5
0E29:  MOVF   65,W
0E2A:  BSF    03.5
0E2B:  MOVWF  30
0E2C:  BCF    03.5
0E2D:  MOVF   64,W
0E2E:  BSF    03.5
0E2F:  MOVWF  37
0E30:  BCF    03.5
0E31:  MOVF   63,W
0E32:  BSF    03.5
0E33:  MOVWF  36
0E34:  BCF    03.5
0E35:  MOVF   62,W
0E36:  BSF    03.5
0E37:  MOVWF  35
0E38:  BCF    03.5
0E39:  MOVF   61,W
0E3A:  BSF    03.5
0E3B:  MOVWF  34
0E3C:  BCF    0A.3
0E3D:  BCF    03.5
0E3E:  CALL   145
0E3F:  BSF    0A.3
0E40:  MOVF   7A,W
0E41:  MOVWF  68
0E42:  MOVF   79,W
0E43:  MOVWF  67
0E44:  MOVF   78,W
0E45:  MOVWF  66
0E46:  MOVF   77,W
0E47:  MOVWF  65
0E48:  MOVF   68,W
0E49:  MOVWF  6C
0E4A:  MOVF   67,W
0E4B:  MOVWF  6B
0E4C:  MOVF   66,W
0E4D:  MOVWF  6A
0E4E:  MOVF   65,W
0E4F:  MOVWF  69
0E50:  CALL   20C
....................       } 
....................    } 
0E51:  BCF    0A.3
0E52:  BSF    0A.4
0E53:  GOTO   384 (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses XT,NOWDT,NOPROTECT,NOLVP,PUT,BROWNOUT 
.................... #use DELAY (CLOCK=4MHz) 
*
0004:  MOVLW  59
0005:  MOVWF  04
0006:  BCF    03.7
0007:  MOVF   00,W
0008:  BTFSC  03.2
0009:  GOTO   018
000A:  MOVLW  01
000B:  MOVWF  78
000C:  CLRF   77
000D:  DECFSZ 77,F
000E:  GOTO   00D
000F:  DECFSZ 78,F
0010:  GOTO   00C
0011:  MOVLW  4A
0012:  MOVWF  77
0013:  DECFSZ 77,F
0014:  GOTO   013
0015:  GOTO   016
0016:  DECFSZ 00,F
0017:  GOTO   00A
0018:  RETURN
.................... #use rs232 (baud=9600,parity=N,xmit=pin_c6,rcv=pin_c7,bits=8) 
....................  
.................... float distancia,tiempo; 
.................... float rtdData, temperatura; 
.................... float ldrData, resistorVoltage,ldrVoltage, ldrResistance, ldrLux; 
.................... float aux1 = -1.00; 
.................... float aux2= -1.00; 
.................... float aux3 = -1.00; 
.................... float aux4=0.00; //resta para saber cuanta distancia queda por llenar  
....................  
.................... #define trigger pin_B1 
.................... #define echo pin_B0 
....................  
.................... int Timer2,Postcaler; 
....................  
.................... void main(){ 
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  MOVLW  19
1004:  BSF    03.5
1005:  MOVWF  19
1006:  MOVLW  A6
1007:  MOVWF  18
1008:  MOVLW  90
1009:  BCF    03.5
100A:  MOVWF  18
100B:  CLRF   49
100C:  CLRF   48
100D:  MOVLW  80
100E:  MOVWF  47
100F:  MOVLW  7F
1010:  MOVWF  46
1011:  CLRF   4D
1012:  CLRF   4C
1013:  MOVLW  80
1014:  MOVWF  4B
1015:  MOVLW  7F
1016:  MOVWF  4A
1017:  CLRF   51
1018:  CLRF   50
1019:  MOVLW  80
101A:  MOVWF  4F
101B:  MOVLW  7F
101C:  MOVWF  4E
101D:  CLRF   55
101E:  CLRF   54
101F:  CLRF   53
1020:  CLRF   52
1021:  MOVLW  FF
1022:  MOVWF  58
1023:  BSF    03.5
1024:  BSF    1F.0
1025:  BSF    1F.1
1026:  BSF    1F.2
1027:  BCF    1F.3
1028:  MOVLW  07
1029:  MOVWF  1C
102A:  BCF    03.7
....................    set_tris_a(0x03); 
*
102E:  MOVLW  03
102F:  BSF    03.5
1030:  MOVWF  05
....................    setup_adc_ports(all_analog); 
1031:  BCF    1F.0
1032:  BCF    1F.1
1033:  BCF    1F.2
1034:  BCF    1F.3
....................    setup_adc(adc_clock_internal); 
1035:  BCF    1F.6
1036:  BCF    03.5
1037:  BSF    1F.6
1038:  BSF    1F.7
1039:  BSF    03.5
103A:  BSF    1F.7
103B:  BCF    03.5
103C:  BSF    1F.0
....................    setup_timer_1(T1_internal|T1_div_by_1); 
103D:  MOVLW  85
103E:  MOVWF  10
....................    Timer2=124; 
103F:  MOVLW  7C
1040:  MOVWF  56
....................    Postcaler=1; 
1041:  MOVLW  01
1042:  MOVWF  57
....................    setup_timer_2(t2_div_by_4,Timer2,Postcaler); 
1043:  SUBWF  57,W
1044:  MOVWF  78
1045:  RLF    78,W
1046:  MOVWF  77
1047:  RLF    77,F
1048:  RLF    77,F
1049:  MOVLW  F8
104A:  ANDWF  77,F
104B:  MOVF   77,W
104C:  IORLW  05
104D:  MOVWF  12
104E:  MOVF   56,W
104F:  BSF    03.5
1050:  MOVWF  12
....................    setup_ccp1(ccp_pwm); 
1051:  BCF    03.5
1052:  BCF    58.2
1053:  MOVF   58,W
1054:  BSF    03.5
1055:  MOVWF  07
1056:  BCF    03.5
1057:  BCF    07.2
1058:  MOVLW  0C
1059:  MOVWF  17
....................    while(true){ 
....................        
....................       set_adc_channel(0); 
105A:  MOVLW  00
105B:  MOVWF  78
105C:  MOVF   1F,W
105D:  ANDLW  C7
105E:  IORWF  78,W
105F:  MOVWF  1F
....................       delay_ms(50); 
1060:  MOVLW  32
1061:  MOVWF  59
1062:  BCF    0A.4
1063:  CALL   004
1064:  BSF    0A.4
....................       rtdData = read_adc(); 
1065:  BSF    1F.2
1066:  BTFSC  1F.2
1067:  GOTO   066
1068:  MOVF   1E,W
1069:  MOVWF  7A
106A:  BSF    03.5
106B:  MOVF   1E,W
106C:  MOVWF  34
106D:  MOVF   7A,W
106E:  MOVWF  35
106F:  BCF    0A.4
1070:  BCF    03.5
1071:  CALL   019
1072:  BSF    0A.4
1073:  MOVF   7A,W
1074:  MOVWF  2D
1075:  MOVF   79,W
1076:  MOVWF  2C
1077:  MOVF   78,W
1078:  MOVWF  2B
1079:  MOVF   77,W
107A:  MOVWF  2A
....................        
....................       set_adc_channel(1); 
107B:  MOVLW  08
107C:  MOVWF  78
107D:  MOVF   1F,W
107E:  ANDLW  C7
107F:  IORWF  78,W
1080:  MOVWF  1F
....................       delay_ms(50); 
1081:  MOVLW  32
1082:  MOVWF  59
1083:  BCF    0A.4
1084:  CALL   004
1085:  BSF    0A.4
....................       ldrData = read_adc(); 
1086:  BSF    1F.2
1087:  BTFSC  1F.2
1088:  GOTO   087
1089:  MOVF   1E,W
108A:  MOVWF  7A
108B:  BSF    03.5
108C:  MOVF   1E,W
108D:  MOVWF  34
108E:  MOVF   7A,W
108F:  MOVWF  35
1090:  BCF    0A.4
1091:  BCF    03.5
1092:  CALL   019
1093:  BSF    0A.4
1094:  MOVF   7A,W
1095:  MOVWF  35
1096:  MOVF   79,W
1097:  MOVWF  34
1098:  MOVF   78,W
1099:  MOVWF  33
109A:  MOVF   77,W
109B:  MOVWF  32
....................        
....................       output_high(trigger); 
109C:  BSF    03.5
109D:  BCF    06.1
109E:  BCF    03.5
109F:  BSF    06.1
....................       delay_us(10); 
10A0:  MOVLW  02
10A1:  MOVWF  77
10A2:  DECFSZ 77,F
10A3:  GOTO   0A2
10A4:  GOTO   0A5
10A5:  NOP
....................       output_low(trigger); 
10A6:  BSF    03.5
10A7:  BCF    06.1
10A8:  BCF    03.5
10A9:  BCF    06.1
....................        
....................       while(!input(echo)); 
10AA:  BSF    03.5
10AB:  BSF    06.0
10AC:  BCF    03.5
10AD:  BTFSS  06.0
10AE:  GOTO   0AA
....................       set_timer1(0); 
10AF:  CLRF   0E
10B0:  CLRF   0F
10B1:  CLRF   0E
....................        
....................       while(input(echo)); 
10B2:  BSF    03.5
10B3:  BSF    06.0
10B4:  BCF    03.5
10B5:  BTFSC  06.0
10B6:  GOTO   0B2
....................       tiempo = get_timer1(); 
10B7:  MOVF   0F,W
10B8:  MOVWF  7A
10B9:  MOVF   0E,W
10BA:  MOVWF  77
10BB:  MOVF   0F,W
10BC:  SUBWF  7A,W
10BD:  BTFSS  03.2
10BE:  GOTO   0B7
10BF:  MOVF   77,W
10C0:  BSF    03.5
10C1:  MOVWF  34
10C2:  MOVF   7A,W
10C3:  MOVWF  35
10C4:  BCF    0A.4
10C5:  BCF    03.5
10C6:  CALL   019
10C7:  BSF    0A.4
10C8:  MOVF   7A,W
10C9:  MOVWF  29
10CA:  MOVF   79,W
10CB:  MOVWF  28
10CC:  MOVF   78,W
10CD:  MOVWF  27
10CE:  MOVF   77,W
10CF:  MOVWF  26
....................        
....................       if(aux1 != tiempo){ 
10D0:  MOVF   49,W
10D1:  BSF    03.5
10D2:  MOVWF  33
10D3:  BCF    03.5
10D4:  MOVF   48,W
10D5:  BSF    03.5
10D6:  MOVWF  32
10D7:  BCF    03.5
10D8:  MOVF   47,W
10D9:  BSF    03.5
10DA:  MOVWF  31
10DB:  BCF    03.5
10DC:  MOVF   46,W
10DD:  BSF    03.5
10DE:  MOVWF  30
10DF:  BCF    03.5
10E0:  MOVF   29,W
10E1:  BSF    03.5
10E2:  MOVWF  37
10E3:  BCF    03.5
10E4:  MOVF   28,W
10E5:  BSF    03.5
10E6:  MOVWF  36
10E7:  BCF    03.5
10E8:  MOVF   27,W
10E9:  BSF    03.5
10EA:  MOVWF  35
10EB:  BCF    03.5
10EC:  MOVF   26,W
10ED:  BSF    03.5
10EE:  MOVWF  34
10EF:  BCF    0A.4
10F0:  BCF    03.5
10F1:  CALL   038
10F2:  BSF    0A.4
10F3:  BTFSC  03.2
10F4:  GOTO   1E3
....................          aux1 = tiempo; 
10F5:  MOVF   29,W
10F6:  MOVWF  49
10F7:  MOVF   28,W
10F8:  MOVWF  48
10F9:  MOVF   27,W
10FA:  MOVWF  47
10FB:  MOVF   26,W
10FC:  MOVWF  46
....................          distancia=(tiempo/2)*(0.0343); 
10FD:  MOVF   29,W
10FE:  BSF    03.5
10FF:  MOVWF  2C
1100:  BCF    03.5
1101:  MOVF   28,W
1102:  BSF    03.5
1103:  MOVWF  2B
1104:  BCF    03.5
1105:  MOVF   27,W
1106:  BSF    03.5
1107:  MOVWF  2A
1108:  BCF    03.5
1109:  MOVF   26,W
110A:  BSF    03.5
110B:  MOVWF  29
110C:  CLRF   30
110D:  CLRF   2F
110E:  CLRF   2E
110F:  MOVLW  80
1110:  MOVWF  2D
1111:  BCF    0A.4
1112:  BCF    03.5
1113:  CALL   079
1114:  BSF    0A.4
1115:  MOVF   7A,W
1116:  MOVWF  5C
1117:  MOVF   79,W
1118:  MOVWF  5B
1119:  MOVF   78,W
111A:  MOVWF  5A
111B:  MOVF   77,W
111C:  MOVWF  59
111D:  MOVF   5C,W
111E:  BSF    03.5
111F:  MOVWF  33
1120:  BCF    03.5
1121:  MOVF   5B,W
1122:  BSF    03.5
1123:  MOVWF  32
1124:  BCF    03.5
1125:  MOVF   5A,W
1126:  BSF    03.5
1127:  MOVWF  31
1128:  BCF    03.5
1129:  MOVF   59,W
112A:  BSF    03.5
112B:  MOVWF  30
112C:  MOVLW  28
112D:  MOVWF  37
112E:  MOVLW  7E
112F:  MOVWF  36
1130:  MOVLW  0C
1131:  MOVWF  35
1132:  MOVLW  7A
1133:  MOVWF  34
1134:  BCF    0A.4
1135:  BCF    03.5
1136:  CALL   145
1137:  BSF    0A.4
1138:  MOVF   7A,W
1139:  MOVWF  25
113A:  MOVF   79,W
113B:  MOVWF  24
113C:  MOVF   78,W
113D:  MOVWF  23
113E:  MOVF   77,W
113F:  MOVWF  22
....................          aux4=distancia-3.00; 
1140:  BSF    03.1
1141:  MOVF   25,W
1142:  BSF    03.5
1143:  MOVWF  37
1144:  BCF    03.5
1145:  MOVF   24,W
1146:  BSF    03.5
1147:  MOVWF  36
1148:  BCF    03.5
1149:  MOVF   23,W
114A:  BSF    03.5
114B:  MOVWF  35
114C:  BCF    03.5
114D:  MOVF   22,W
114E:  BSF    03.5
114F:  MOVWF  34
1150:  CLRF   3B
1151:  CLRF   3A
1152:  MOVLW  40
1153:  MOVWF  39
1154:  MOVLW  80
1155:  MOVWF  38
1156:  BCF    0A.4
1157:  BCF    03.5
1158:  CALL   1BC
1159:  BSF    0A.4
115A:  MOVF   7A,W
115B:  MOVWF  55
115C:  MOVF   79,W
115D:  MOVWF  54
115E:  MOVF   78,W
115F:  MOVWF  53
1160:  MOVF   77,W
1161:  MOVWF  52
....................     
....................          printf("\rd%f\n", aux4); //imprime dist que resta por llenar 
1162:  MOVLW  0D
1163:  BTFSS  0C.4
1164:  GOTO   163
1165:  MOVWF  19
1166:  MOVLW  64
1167:  BTFSS  0C.4
1168:  GOTO   167
1169:  MOVWF  19
116A:  MOVLW  89
116B:  MOVWF  04
116C:  MOVF   55,W
116D:  MOVWF  5C
116E:  MOVF   54,W
116F:  MOVWF  5B
1170:  MOVF   53,W
1171:  MOVWF  5A
1172:  MOVF   52,W
1173:  MOVWF  59
1174:  MOVLW  02
1175:  MOVWF  5D
1176:  BCF    0A.4
1177:  CALL   351
1178:  BSF    0A.4
1179:  MOVLW  0A
117A:  BTFSS  0C.4
117B:  GOTO   17A
117C:  MOVWF  19
....................          if(distancia<=99.54 && distancia>=4){ 
117D:  MOVF   25,W
117E:  BSF    03.5
117F:  MOVWF  33
1180:  BCF    03.5
1181:  MOVF   24,W
1182:  BSF    03.5
1183:  MOVWF  32
1184:  BCF    03.5
1185:  MOVF   23,W
1186:  BSF    03.5
1187:  MOVWF  31
1188:  BCF    03.5
1189:  MOVF   22,W
118A:  BSF    03.5
118B:  MOVWF  30
118C:  MOVLW  7B
118D:  MOVWF  37
118E:  MOVLW  14
118F:  MOVWF  36
1190:  MOVLW  47
1191:  MOVWF  35
1192:  MOVLW  85
1193:  MOVWF  34
1194:  BCF    0A.4
1195:  BCF    03.5
1196:  CALL   038
1197:  BSF    0A.4
1198:  BTFSC  03.0
1199:  GOTO   19C
119A:  BTFSS  03.2
119B:  GOTO   1C1
119C:  BSF    03.5
119D:  CLRF   33
119E:  CLRF   32
119F:  CLRF   31
11A0:  MOVLW  81
11A1:  MOVWF  30
11A2:  BCF    03.5
11A3:  MOVF   25,W
11A4:  BSF    03.5
11A5:  MOVWF  37
11A6:  BCF    03.5
11A7:  MOVF   24,W
11A8:  BSF    03.5
11A9:  MOVWF  36
11AA:  BCF    03.5
11AB:  MOVF   23,W
11AC:  BSF    03.5
11AD:  MOVWF  35
11AE:  BCF    03.5
11AF:  MOVF   22,W
11B0:  BSF    03.5
11B1:  MOVWF  34
11B2:  BCF    0A.4
11B3:  BCF    03.5
11B4:  CALL   038
11B5:  BSF    0A.4
11B6:  BTFSC  03.0
11B7:  GOTO   1BA
11B8:  BTFSS  03.2
11B9:  GOTO   1C1
....................             set_pwm1_duty(1023); 
11BA:  MOVLW  FF
11BB:  MOVWF  15
11BC:  MOVF   17,W
11BD:  ANDLW  CF
11BE:  IORLW  30
11BF:  MOVWF  17
....................          } 
11C0:  GOTO   1E3
....................          else if(distancia>99.54){ 
11C1:  MOVLW  7B
11C2:  BSF    03.5
11C3:  MOVWF  33
11C4:  MOVLW  14
11C5:  MOVWF  32
11C6:  MOVLW  47
11C7:  MOVWF  31
11C8:  MOVLW  85
11C9:  MOVWF  30
11CA:  BCF    03.5
11CB:  MOVF   25,W
11CC:  BSF    03.5
11CD:  MOVWF  37
11CE:  BCF    03.5
11CF:  MOVF   24,W
11D0:  BSF    03.5
11D1:  MOVWF  36
11D2:  BCF    03.5
11D3:  MOVF   23,W
11D4:  BSF    03.5
11D5:  MOVWF  35
11D6:  BCF    03.5
11D7:  MOVF   22,W
11D8:  BSF    03.5
11D9:  MOVWF  34
11DA:  BCF    0A.4
11DB:  BCF    03.5
11DC:  CALL   038
11DD:  BSF    0A.4
11DE:  BTFSS  03.0
11DF:  GOTO   1E2
....................             set_pwm1_duty(0); 
11E0:  CLRF   15
....................             //printf("\rdvacio\n"); 
....................          } 
11E1:  GOTO   1E3
....................          else{ 
....................             set_pwm1_duty(0); 
11E2:  CLRF   15
....................             //printf("\rdlleno\n"); 
....................          } 
....................       } 
....................        
....................       if(aux2 != rtdData){ 
11E3:  MOVF   4D,W
11E4:  BSF    03.5
11E5:  MOVWF  33
11E6:  BCF    03.5
11E7:  MOVF   4C,W
11E8:  BSF    03.5
11E9:  MOVWF  32
11EA:  BCF    03.5
11EB:  MOVF   4B,W
11EC:  BSF    03.5
11ED:  MOVWF  31
11EE:  BCF    03.5
11EF:  MOVF   4A,W
11F0:  BSF    03.5
11F1:  MOVWF  30
11F2:  BCF    03.5
11F3:  MOVF   2D,W
11F4:  BSF    03.5
11F5:  MOVWF  37
11F6:  BCF    03.5
11F7:  MOVF   2C,W
11F8:  BSF    03.5
11F9:  MOVWF  36
11FA:  BCF    03.5
11FB:  MOVF   2B,W
11FC:  BSF    03.5
11FD:  MOVWF  35
11FE:  BCF    03.5
11FF:  MOVF   2A,W
1200:  BSF    03.5
1201:  MOVWF  34
1202:  BCF    0A.4
1203:  BCF    03.5
1204:  CALL   038
1205:  BSF    0A.4
1206:  BTFSC  03.2
1207:  GOTO   26E
....................          aux2 = rtdData; 
1208:  MOVF   2D,W
1209:  MOVWF  4D
120A:  MOVF   2C,W
120B:  MOVWF  4C
120C:  MOVF   2B,W
120D:  MOVWF  4B
120E:  MOVF   2A,W
120F:  MOVWF  4A
....................          temperatura = (rtdData*100.0)/1023.0; 
1210:  MOVF   2D,W
1211:  BSF    03.5
1212:  MOVWF  33
1213:  BCF    03.5
1214:  MOVF   2C,W
1215:  BSF    03.5
1216:  MOVWF  32
1217:  BCF    03.5
1218:  MOVF   2B,W
1219:  BSF    03.5
121A:  MOVWF  31
121B:  BCF    03.5
121C:  MOVF   2A,W
121D:  BSF    03.5
121E:  MOVWF  30
121F:  CLRF   37
1220:  CLRF   36
1221:  MOVLW  48
1222:  MOVWF  35
1223:  MOVLW  85
1224:  MOVWF  34
1225:  BCF    0A.4
1226:  BCF    03.5
1227:  CALL   145
1228:  BSF    0A.4
1229:  MOVF   7A,W
122A:  MOVWF  5C
122B:  MOVF   79,W
122C:  MOVWF  5B
122D:  MOVF   78,W
122E:  MOVWF  5A
122F:  MOVF   77,W
1230:  MOVWF  59
1231:  MOVF   5C,W
1232:  BSF    03.5
1233:  MOVWF  2C
1234:  BCF    03.5
1235:  MOVF   5B,W
1236:  BSF    03.5
1237:  MOVWF  2B
1238:  BCF    03.5
1239:  MOVF   5A,W
123A:  BSF    03.5
123B:  MOVWF  2A
123C:  BCF    03.5
123D:  MOVF   59,W
123E:  BSF    03.5
123F:  MOVWF  29
1240:  CLRF   30
1241:  MOVLW  C0
1242:  MOVWF  2F
1243:  MOVLW  7F
1244:  MOVWF  2E
1245:  MOVLW  88
1246:  MOVWF  2D
1247:  BCF    0A.4
1248:  BCF    03.5
1249:  CALL   079
124A:  BSF    0A.4
124B:  MOVF   7A,W
124C:  MOVWF  31
124D:  MOVF   79,W
124E:  MOVWF  30
124F:  MOVF   78,W
1250:  MOVWF  2F
1251:  MOVF   77,W
1252:  MOVWF  2E
....................          printf("\rt%0.2f\n", temperatura); 
1253:  MOVLW  0D
1254:  BTFSS  0C.4
1255:  GOTO   254
1256:  MOVWF  19
1257:  MOVLW  74
1258:  BTFSS  0C.4
1259:  GOTO   258
125A:  MOVWF  19
125B:  MOVLW  C9
125C:  MOVWF  04
125D:  MOVF   31,W
125E:  MOVWF  5C
125F:  MOVF   30,W
1260:  MOVWF  5B
1261:  MOVF   2F,W
1262:  MOVWF  5A
1263:  MOVF   2E,W
1264:  MOVWF  59
1265:  MOVLW  02
1266:  MOVWF  5D
1267:  BCF    0A.4
1268:  CALL   351
1269:  BSF    0A.4
126A:  MOVLW  0A
126B:  BTFSS  0C.4
126C:  GOTO   26B
126D:  MOVWF  19
....................       } 
....................        
....................       if(aux3 != ldrData){ 
126E:  MOVF   51,W
126F:  BSF    03.5
1270:  MOVWF  33
1271:  BCF    03.5
1272:  MOVF   50,W
1273:  BSF    03.5
1274:  MOVWF  32
1275:  BCF    03.5
1276:  MOVF   4F,W
1277:  BSF    03.5
1278:  MOVWF  31
1279:  BCF    03.5
127A:  MOVF   4E,W
127B:  BSF    03.5
127C:  MOVWF  30
127D:  BCF    03.5
127E:  MOVF   35,W
127F:  BSF    03.5
1280:  MOVWF  37
1281:  BCF    03.5
1282:  MOVF   34,W
1283:  BSF    03.5
1284:  MOVWF  36
1285:  BCF    03.5
1286:  MOVF   33,W
1287:  BSF    03.5
1288:  MOVWF  35
1289:  BCF    03.5
128A:  MOVF   32,W
128B:  BSF    03.5
128C:  MOVWF  34
128D:  BCF    0A.4
128E:  BCF    03.5
128F:  CALL   038
1290:  BSF    0A.4
1291:  BTFSC  03.2
1292:  GOTO   3BF
....................          aux3 = ldrData; 
1293:  MOVF   35,W
1294:  MOVWF  51
1295:  MOVF   34,W
1296:  MOVWF  50
1297:  MOVF   33,W
1298:  MOVWF  4F
1299:  MOVF   32,W
129A:  MOVWF  4E
....................          resistorVoltage = ldrData / 1023.0 * 5.0; 
129B:  MOVF   35,W
129C:  BSF    03.5
129D:  MOVWF  2C
129E:  BCF    03.5
129F:  MOVF   34,W
12A0:  BSF    03.5
12A1:  MOVWF  2B
12A2:  BCF    03.5
12A3:  MOVF   33,W
12A4:  BSF    03.5
12A5:  MOVWF  2A
12A6:  BCF    03.5
12A7:  MOVF   32,W
12A8:  BSF    03.5
12A9:  MOVWF  29
12AA:  CLRF   30
12AB:  MOVLW  C0
12AC:  MOVWF  2F
12AD:  MOVLW  7F
12AE:  MOVWF  2E
12AF:  MOVLW  88
12B0:  MOVWF  2D
12B1:  BCF    0A.4
12B2:  BCF    03.5
12B3:  CALL   079
12B4:  BSF    0A.4
12B5:  MOVF   7A,W
12B6:  MOVWF  5C
12B7:  MOVF   79,W
12B8:  MOVWF  5B
12B9:  MOVF   78,W
12BA:  MOVWF  5A
12BB:  MOVF   77,W
12BC:  MOVWF  59
12BD:  MOVF   5C,W
12BE:  BSF    03.5
12BF:  MOVWF  33
12C0:  BCF    03.5
12C1:  MOVF   5B,W
12C2:  BSF    03.5
12C3:  MOVWF  32
12C4:  BCF    03.5
12C5:  MOVF   5A,W
12C6:  BSF    03.5
12C7:  MOVWF  31
12C8:  BCF    03.5
12C9:  MOVF   59,W
12CA:  BSF    03.5
12CB:  MOVWF  30
12CC:  CLRF   37
12CD:  CLRF   36
12CE:  MOVLW  20
12CF:  MOVWF  35
12D0:  MOVLW  81
12D1:  MOVWF  34
12D2:  BCF    0A.4
12D3:  BCF    03.5
12D4:  CALL   145
12D5:  BSF    0A.4
12D6:  MOVF   7A,W
12D7:  MOVWF  39
12D8:  MOVF   79,W
12D9:  MOVWF  38
12DA:  MOVF   78,W
12DB:  MOVWF  37
12DC:  MOVF   77,W
12DD:  MOVWF  36
....................          ldrVoltage = 5.0 - resistorVoltage; 
12DE:  BSF    03.1
12DF:  BSF    03.5
12E0:  CLRF   37
12E1:  CLRF   36
12E2:  MOVLW  20
12E3:  MOVWF  35
12E4:  MOVLW  81
12E5:  MOVWF  34
12E6:  BCF    03.5
12E7:  MOVF   39,W
12E8:  BSF    03.5
12E9:  MOVWF  3B
12EA:  BCF    03.5
12EB:  MOVF   38,W
12EC:  BSF    03.5
12ED:  MOVWF  3A
12EE:  BCF    03.5
12EF:  MOVF   37,W
12F0:  BSF    03.5
12F1:  MOVWF  39
12F2:  BCF    03.5
12F3:  MOVF   36,W
12F4:  BSF    03.5
12F5:  MOVWF  38
12F6:  BCF    0A.4
12F7:  BCF    03.5
12F8:  CALL   1BC
12F9:  BSF    0A.4
12FA:  MOVF   7A,W
12FB:  MOVWF  3D
12FC:  MOVF   79,W
12FD:  MOVWF  3C
12FE:  MOVF   78,W
12FF:  MOVWF  3B
1300:  MOVF   77,W
1301:  MOVWF  3A
....................          ldrResistance = (resistorVoltage* 51000.0) /ldrVoltage; 
1302:  MOVF   39,W
1303:  BSF    03.5
1304:  MOVWF  33
1305:  BCF    03.5
1306:  MOVF   38,W
1307:  BSF    03.5
1308:  MOVWF  32
1309:  BCF    03.5
130A:  MOVF   37,W
130B:  BSF    03.5
130C:  MOVWF  31
130D:  BCF    03.5
130E:  MOVF   36,W
130F:  BSF    03.5
1310:  MOVWF  30
1311:  CLRF   37
1312:  MOVLW  38
1313:  MOVWF  36
1314:  MOVLW  47
1315:  MOVWF  35
1316:  MOVLW  8E
1317:  MOVWF  34
1318:  BCF    0A.4
1319:  BCF    03.5
131A:  CALL   145
131B:  BSF    0A.4
131C:  MOVF   7A,W
131D:  MOVWF  5C
131E:  MOVF   79,W
131F:  MOVWF  5B
1320:  MOVF   78,W
1321:  MOVWF  5A
1322:  MOVF   77,W
1323:  MOVWF  59
1324:  MOVF   5C,W
1325:  BSF    03.5
1326:  MOVWF  2C
1327:  BCF    03.5
1328:  MOVF   5B,W
1329:  BSF    03.5
132A:  MOVWF  2B
132B:  BCF    03.5
132C:  MOVF   5A,W
132D:  BSF    03.5
132E:  MOVWF  2A
132F:  BCF    03.5
1330:  MOVF   59,W
1331:  BSF    03.5
1332:  MOVWF  29
1333:  BCF    03.5
1334:  MOVF   3D,W
1335:  BSF    03.5
1336:  MOVWF  30
1337:  BCF    03.5
1338:  MOVF   3C,W
1339:  BSF    03.5
133A:  MOVWF  2F
133B:  BCF    03.5
133C:  MOVF   3B,W
133D:  BSF    03.5
133E:  MOVWF  2E
133F:  BCF    03.5
1340:  MOVF   3A,W
1341:  BSF    03.5
1342:  MOVWF  2D
1343:  BCF    0A.4
1344:  BCF    03.5
1345:  CALL   079
1346:  BSF    0A.4
1347:  MOVF   7A,W
1348:  MOVWF  41
1349:  MOVF   79,W
134A:  MOVWF  40
134B:  MOVF   78,W
134C:  MOVWF  3F
134D:  MOVF   77,W
134E:  MOVWF  3E
....................          ldrLux = 1.0/pow(ldrResistance/127410.00, 1/0.8582017); 
134F:  MOVF   41,W
1350:  BSF    03.5
1351:  MOVWF  2C
1352:  BCF    03.5
1353:  MOVF   40,W
1354:  BSF    03.5
1355:  MOVWF  2B
1356:  BCF    03.5
1357:  MOVF   3F,W
1358:  BSF    03.5
1359:  MOVWF  2A
135A:  BCF    03.5
135B:  MOVF   3E,W
135C:  BSF    03.5
135D:  MOVWF  29
135E:  CLRF   30
135F:  MOVLW  D9
1360:  MOVWF  2F
1361:  MOVLW  78
1362:  MOVWF  2E
1363:  MOVLW  8F
1364:  MOVWF  2D
1365:  BCF    0A.4
1366:  BCF    03.5
1367:  CALL   079
1368:  BSF    0A.4
1369:  MOVF   7A,W
136A:  MOVWF  5C
136B:  MOVF   79,W
136C:  MOVWF  5B
136D:  MOVF   78,W
136E:  MOVWF  5A
136F:  MOVF   77,W
1370:  MOVWF  59
1371:  MOVF   5C,W
1372:  MOVWF  60
1373:  MOVF   5B,W
1374:  MOVWF  5F
1375:  MOVF   5A,W
1376:  MOVWF  5E
1377:  MOVF   59,W
1378:  MOVWF  5D
1379:  MOVLW  2B
137A:  MOVWF  64
137B:  MOVLW  26
137C:  MOVWF  63
137D:  MOVLW  15
137E:  MOVWF  62
137F:  MOVLW  7F
1380:  MOVWF  61
1381:  BCF    0A.4
1382:  BSF    0A.3
1383:  GOTO   46D
1384:  BSF    0A.4
1385:  BCF    0A.3
1386:  BSF    03.5
1387:  CLRF   2C
1388:  CLRF   2B
1389:  CLRF   2A
138A:  MOVLW  7F
138B:  MOVWF  29
138C:  MOVF   7A,W
138D:  MOVWF  30
138E:  MOVF   79,W
138F:  MOVWF  2F
1390:  MOVF   78,W
1391:  MOVWF  2E
1392:  MOVF   77,W
1393:  MOVWF  2D
1394:  BCF    0A.4
1395:  BCF    03.5
1396:  CALL   079
1397:  BSF    0A.4
1398:  MOVF   7A,W
1399:  MOVWF  45
139A:  MOVF   79,W
139B:  MOVWF  44
139C:  MOVF   78,W
139D:  MOVWF  43
139E:  MOVF   77,W
139F:  MOVWF  42
....................          printf(" \rx%0.2f\n",ldrLux); 
13A0:  MOVLW  20
13A1:  BTFSS  0C.4
13A2:  GOTO   3A1
13A3:  MOVWF  19
13A4:  MOVLW  0D
13A5:  BTFSS  0C.4
13A6:  GOTO   3A5
13A7:  MOVWF  19
13A8:  MOVLW  78
13A9:  BTFSS  0C.4
13AA:  GOTO   3A9
13AB:  MOVWF  19
13AC:  MOVLW  C9
13AD:  MOVWF  04
13AE:  MOVF   45,W
13AF:  MOVWF  5C
13B0:  MOVF   44,W
13B1:  MOVWF  5B
13B2:  MOVF   43,W
13B3:  MOVWF  5A
13B4:  MOVF   42,W
13B5:  MOVWF  59
13B6:  MOVLW  02
13B7:  MOVWF  5D
13B8:  BCF    0A.4
13B9:  CALL   351
13BA:  BSF    0A.4
13BB:  MOVLW  0A
13BC:  BTFSS  0C.4
13BD:  GOTO   3BC
13BE:  MOVWF  19
....................       } 
13BF:  GOTO   05A
....................        
....................    } 
.................... } 
....................  
13C0:  SLEEP
....................  
....................  

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
